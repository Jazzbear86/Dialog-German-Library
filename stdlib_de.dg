
(library version)
	Bibliothek 0.36. DE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 1: Global variables

%% The following variables may be queried directly from the story, but the
%% library gets confused if you modify them directly with (now). Instead, use
%% the predicates mentioned in the comments:

%% Update with (select player $):
(global variable (current player $))

%% Update with (enter $) or (move player to $ $):
(global variable (current room $))

%% Update with (increase score by $) or (decrease score by $):
(global variable (current score $))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Style class declarations

%% These declarations are merely hints to the backend and/or interpreter.

%% Attributes can be ignored based on context. On the Z-machine backend, for
%% instance, 'height' only has an effect on (status bar $) boxes, whereas
%% 'width' and 'float' only affect (div $) boxes that are nested inside a
%% (status bar $) box. The height and width may be specified in em/ch or %.

(style class @status)
	height: 1em;

(style class @score)
	float: right;
	width: 17ch;

(style class @initial-spacer)
	margin-bottom: 2em;

(style class @title)
	font-family: Geneva, sans-serif;
	font-weight: bold;
	font-size: 1.4em;
	margin-top: 1em;

(style class @roomheader)
	margin-top: .3em;
	font-family: Geneva, sans-serif;

(style class @bold)
	font-weight: bold;

(style class @italic)
	font-style: italic;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Interface declarations for predicates typically defined in story code

(interface (name $<Obj))
(interface (descr $<Obj))
(interface (appearance $<Obj))
(interface (appearance $<Obj $<Rel $<Loc))
(interface (feel $<Obj))
(interface (room header $<Obj))
(interface (look $<Obj))

(interface (dict $<Obj))
(interface (plural dict $<Obj))
(interface (heads $<Obj))

(interface (from $<Room go $>Dir to $>Obj))
(interface (from $<Room through $>Door to $>Obj))

(interface (add $>Obj to scope))
(interface ($<Room attracts $>Obj))

(interface (maximum score $>Number))

(interface (clarify location of $<Obj))
(interface ($>Obj provides light))
(interface ($<Key unlocks $<Door))

(interface ($<Door blocks passage))
(interface ($<Door blocks light))

(interface (fungible $<Obj1 $<Obj2))

(interface (on every tick in $<Room))

(interface (understand $<Words as $>Action))
(interface (understand $<Words))

(interface (describe action $<Action))
(interface (unlikely $<Action))
(interface (very unlikely $<Action))

(interface (before $<Action))
(interface (refuse $<Action))
(interface (instead of $<Action))
(interface (prevent $<Action))
(interface (perform $<Action))
(interface (after $<Action))

(interface (narrate taking $<Obj))
(interface (narrate removing $<Obj))
(interface (narrate wearing $<Obj))
(interface (narrate putting $<Obj $<Rel $<Dest))
(interface (narrate dropping $<Obj))
(interface (narrate opening $<Obj))
(interface (narrate closing $<Obj))
(interface (narrate unlocking $<Obj with $<Key))
(interface (narrate locking $<Obj with $<Key))
(interface (narrate switching on $<Obj))
(interface (narrate switching off $<Obj))
(interface (narrate eating $<Obj))
(interface (narrate climbing $<Obj))
(interface (narrate entering $<Obj))
(interface (narrate leaving $<Obj))
(interface (narrate leaving $<Room $<Dir))
(interface (narrate leaving $<Room $<Dir with $<Obj))
(interface (narrate leaving $<Room $<Dir by $<Vehicle))
(interface (narrate failing to look $<Dir))

(interface (describe topic $<Topic))

(interface (default action $<Obj $>Action))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 2: Relations

(relation #in)		%% Note: #in is also a direction
(relation #on)
(relation #partof)
(relation #heldby)
(relation #wornby)
(relation #under)
(relation #behind)

(name #in)		in
(name #on)		auf
(name #partof)		an
(name #heldby)		im Besitz von 
(name #wornby)		Teil der Kleidung von
(name #under)		unter
(name #behind)		hinter

(Name #partof)		Als fester Teil von

(dict #in)		in durch
(dict #on)		auf
(dict #under)		unter unterm
(dict #behind)		hinter hinterm

(dict #partof)		(just) (fail)
(dict #heldby)		(just) (fail)
(dict #wornby)		(just) (fail)

(interface (present-name $<Rel))

(present-name #in)	in
(present-name #on)	auf
(present-name $Rel)	(name $Rel)

(interface (reverse-name $<Rel))

(reverse-name #in)	aus
(reverse-name #on)	von
(reverse-name #partof)	von
(reverse-name #heldby)	von
(reverse-name #wornby)	von
(reverse-name #under)	unter
(reverse-name #behind)	hinter

(der (relation $Rel))	(name $Rel)
(die (relation $Rel))	(name $Rel)
(den (relation $Rel))	(name $Rel)
(dem (relation $Rel))	(name $Rel)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 3: German Directions

%% Directions are given special treatment during parsing, so there is no need
%% for (dict $) rules here. See (parse direction $ $).

(interface (opposite of $<Dir1 is $>Dir2))

(interface (present-adverb $<Dir))
(interface (from-adverb $<Dir))

#north
(direction *)
(name *)		Norden
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		n nord norden nördlich
(opposite of * is #south)

#south
(direction *)
(name *)		Süden
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		s süd süden südlich
(opposite of * is #north)

#east
(direction *)
(name *)		Osten
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		o ost osten östlich
(opposite of * is #west)

#west
(direction *)
(name *)		Westen
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		w west westen westlich
(opposite of * is #east)

#northeast
(direction *)
(name *)		Nordosten
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		no nordost nordosten nordöstlich
(opposite of * is #southwest)

#northwest
(direction *)
(name *)		Nordwesten
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		nw nordwest nordwesten nordwestlich
(opposite of * is #southeast)

#southwest
(direction *)
(name *)		Südwesten
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		sw südwest südwesten südwestlich
(opposite of * is #northeast)

#southeast
(direction *)
(name *)		Südosten
(to-adverb *)	
	(name *)
(from-adverb *)	
	(name *)
(dict *)		so südost südosten südöstlich
(opposite of * is #northwest)

#up
(direction *)
(name *)		oben
(dict *)		h hinauf rauf hoch oben
(present-adverb *)	über
(from-adverb *)		oben
(to-adverb *)		hinauf
(opposite of * is #down)

#down
(direction *)
(name *)		unten
(dict *)		r runter hinunter hinab unten
(present-adverb *)	unter
(from-adverb *)		unten
(to-adverb *)		hinunter
(opposite of * is #up)

#in			%% Note: #in is also a relation
(direction *)
(name *)		drinnen
(dict *)		rein hinein innen drinnen
(present-adverb *)	innerhalb
(from-adverb *)		drinnen
(to-adverb *)		hinein
(opposite of * is #out)

#out
(direction *)
(name *)		draußen
(dict *)		raus hinaus außen draußen
(present-adverb *)	außerhalb
(from-adverb *)		draußen
(to-adverb *)		hinaus
(opposite of * is #in)

(present-adverb $Dir)	im (name $Dir)
(from-adverb $Dir)	von (name $Dir)

(proper (direction $))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 4: Common traits and per-object flags

%% Negations

@($Obj is open)			~($Obj is closed)
@($Obj is unlocked)		~($Obj is locked)
@($Obj is on)			~($Obj is off)
@($Obj is revealed)		~($Obj is hidden)
@($Obj is pristine)		~($Obj is handled)
@($Obj is unvisited)		~($Obj is visited)
@($Obj is transparent)		~($Obj is opaque)
@($Obj is in order)		~($Obj is broken)

%% Inheritance relations

(actor container $Obj)		*(room $Obj)
(animate $Obj)			*(female $Obj)
(animate $Obj)			*(male $Obj)
($Obj is maskulin)		*(male $Obj)
($Obj is feminin)		*(female $Obj)
(container $Obj)		*(actor container $Obj)
(item $Obj)			*(wearable $Obj)
(supporter $Obj)		*(actor supporter $Obj)
(excluded from all $Obj)	*(not here $Obj)
(excluded from all $Obj)	*(room $Obj)
(actor container $Obj)		*(in-seat $Obj)
(actor supporter $Obj)		*(on-seat $Obj)
(seat $Obj)			*(in-seat $Obj)
(seat $Obj)			*(on-seat $Obj)
(openable $Obj)			*(lockable $Obj)

%% A few actor classes

(animate $Obj)			*(actor $Obj)
(animate $Obj)			*(female actor $Obj)
(animate $Obj)			*(male actor $Obj)
($Obj is feminin)		*(female actor $Obj)
($Obj is maskulin)		*(male actor $Obj)

%% "Edison's Lament: No switch is ever in the right position."
%% (From "The Grand List Of Console Role Playing Game Clichés")
%% Of course, you can override these defaults on an object-by-object basis:

((openable $) is closed)
((lockable $) is locked)
((switchable $) is off)
((openable $) is opaque)

%% Convenience predicate:

(interface (reveal $<Obj))

(reveal $Obj)
	(now) ($Obj is revealed)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 5: Rules to prevent compiler warnings

%% The following rule definitions have no effect on the behaviour of the
%% program, but they prevent warnings about undefined predicates. They have
%% zero impact on performance.

%% These are typically static traits:

(door $)		(fail)
(edible $)		(fail)
(female $)		(fail)
(fine where it is $)	(fail)
(inherently dark $)	(fail)
(intangible $)		(fail)
(item $)		(fail)
(lockable $)		(fail)
(male $)		(fail)
(not here $)		(fail)
(openable $)		(fail)
(out of reach $)	(fail)
(plural $)		(fail)
(potable $)		(fail)
(proper $)		(fail)
(pushable $)		(fail)
(sharp $)		(fail)
(singleton $)		(fail)
(switchable $)		(fail)
(uncountable $)		(fail)
(wearable $)		(fail)
(vehicle $)		(fail)
(your $)		(fail)
(on-seat $)		(fail)
(in-seat $)		(fail)
(consultable $)		(fail)

(actor $)		(fail)
(female actor $)		(fail)
(male actor $)		(fail)

%% These typically involve rule bodies with further conditions:

($ provides light)	(fail)

%% These are typically dynamic (i.e. per-object flags):

($ is broken)		(fail)
($ is hidden)		(fail)

%% German Genders

($ is maskulin)		(fail)
($ is feminin)		(fail)
($ is neutrum)		(fail)
($ is plural)		(fail)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 6: German grammatical cases

#Nominativ
#Genitiv
#Dativ
#Akkusativ

(current case #Akkusativ)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 7: German articles

#Indefinite
#Definite

(current article #Indefinite)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 8: German names written out depending on case and article

(einen [])			nichts
(einen (list $List))	(einen-listing $List)

(ein [])			nichts
(ein (list $List))	(ein-listing $List)

(den [])		etwas Bestimmtes	%% May appear in incomplete actions.
(den full [])	etwas Bestimmtes	%% May appear in incomplete actions.
(dem [])		etwas Bestimmtem	%% May appear in incomplete actions.
(dem full [])	etwas Bestimmtem	%% May appear in incomplete actions.

(den [1])		jemanden		%% May appear in incomplete actions.
(den full [1])	jemanden		%% May appear in incomplete actions.
(dem [1])		jemandem		%% May appear in incomplete actions.
(dem full [1])	jemandem		%% May appear in incomplete actions.

(den [einen $Obj])			(einen $Obj)
(den [+ | $List])		(den-listing $List)
(den (list $List))		(den-listing $List)

(des (list $List))		(des-listing $List)
(der (list $List))		(der-listing $List)
(dem (list $List))		(dem-listing $List)

(den full [einen $Obj])		(einen full $Obj)
(den full [+ | $List])		(den-full-listing $List)
(den full [, | $List])		(den-full-oder-listing $List)
(den full (list $List))		(den-full-listing $List)

(ein ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.
(der ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.

(ein $Obj)		(current player $Obj) du
(Ein $Obj)		(current player $Obj) Du
(eines $Obj)	(current player $Obj) von Dir %% ever needed?
(Eines $Obj)	(current player $Obj) von Dir %% ever needed?
(einem $Obj)	(current player $Obj) dir
(Einem $Obj)	(current player $Obj) Dir
(einen $Obj)	(current player $Obj) dich
(Einen $Obj)	(current player $Obj) Dich

(der $Obj)		(current player $Obj) du
(Der $Obj)		(current player $Obj) Du
(des $Obj)		(current player $Obj) von dir %% ever needed?
(Des $Obj)		(current player $Obj) Von Dir %% ever needed?
(dem $Obj)		(current player $Obj) dir
(Dem $Obj)		(current player $Obj) Dir
(den $Obj)		(current player $Obj) dich
(Den $Obj)		(current player $Obj) Dich

(ein (proper $Obj))		(name $Obj)
(Ein (proper $Obj))		(name $Obj)
(eines (proper $Obj))	(name $Obj)
(Eines (proper $Obj))	(name $Obj)
(einem (proper $Obj))	(name $Obj)
(Einem (proper $Obj))	(name $Obj)
(einen (proper $Obj))	(name $Obj)
(Einen (proper $Obj))	(name $Obj)

(der (proper $Obj))		(name $Obj)
(Der (proper $Obj))		(name $Obj)
(des (proper $Obj))		(name $Obj)
(Des (proper $Obj))		(name $Obj)
(dem (proper $Obj))		(name $Obj)
(Dem (proper $Obj))		(name $Obj)
(den (proper $Obj))		(name $Obj)
(Den (proper $Obj))		(name $Obj)

(ein (singleton $Obj))		(der $Obj)
(eines (singleton $Obj))	(des $Obj)
(einem (singleton $Obj))	(dem $Obj)
(einen (singleton $Obj))	(den $Obj)

(ein (uncountable $Obj))	(name $Obj)
(eines (uncountable $Obj))	(name $Obj)
(einem (uncountable $Obj))	(name $Obj)
(einen (uncountable $Obj))	(name $Obj)

(ein (your $Obj))		
	(now) (current case #Nominativ)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		dein
	(elseif) ($Obj is feminin) (then)
		deine
	(elseif) ($Obj is neutrum) (then)
		dein
	(else)
		deine
	(endif)
	(name $Obj)	

(ein $Obj)		
	(now) (current case #Nominativ)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		ein
	(elseif) ($Obj is feminin) (then)
		eine
	(elseif) ($Obj is neutrum) (then)
		ein
	(else)
		einige	
	(endif)
	(name $Obj)	

(eines (your $Obj))		
	(now) (current case #Genitiv)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		deines
	(elseif) ($Obj is feminin) (then)
		deiner
	(elseif) ($Obj is neutrum) (then)
		deines
	(else)
		deiner
	(endif)
	(name $Obj)	

(eines $Obj)		
	(now) (current case #Genitiv)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		eines
	(elseif) ($Obj is feminin) (then)
		einer
	(elseif) ($Obj is neutrum) (then)
		eines
	(else)
		einiger
	(endif)
	(name $Obj)

(einem (your $Obj))		
	(now) (current case #Dativ)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		deinem
	(elseif) ($Obj is feminin) (then)
		deiner
	(elseif) ($Obj is neutrum) (then)
		deinem
	(else)
		deinen
	(endif)
	(name $Obj)	

(einem $Obj)		
	(now) (current case #Dativ)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		einem
	(elseif) ($Obj is feminin) (then)
		einer
	(elseif) ($Obj is neutrum) (then)
		einem
	(else)
		einigen
	(endif)
	(name $Obj)

(einen (your $Obj))		
	(now) (current case #Akkusativ)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		deinen
	(elseif) ($Obj is feminin) (then)
		deine
	(elseif) ($Obj is neutrum) (then)
		dein
	(else)
		deine
	(endif)
	(name $Obj)	

(einen $Obj)		
	(now) (current case #Akkusativ)
	(now) (current article #Indefinite)
	(if) ($Obj is maskulin) (then)
		einen
	(elseif) ($Obj is feminin) (then)
		eine
	(elseif) ($Obj is neutrum) (then)
		ein
	(else)
		einige
	(endif)
	(name $Obj)

(der (your $Obj))	(ein $Obj)
(des (your $Obj))	(eines $Obj)
(dem (your $Obj))	(einem $Obj)
(den (your $Obj))	(einen $Obj)

(Ein $Obj)		(uppercase) (ein $Obj)
(Eines $Obj)	(uppercase) (eines $Obj)
(Einem $Obj)	(uppercase) (einem $Obj)
(Einen $Obj)	(uppercase) (einen $Obj)
	
(der $Obj)		
	(now) (current case #Nominativ)
	(now) (current article #Definite)
	(if) ($Obj is maskulin) (then)
		der
	(elseif) ($Obj is feminin) (then)
		die
	(elseif) ($Obj is neutrum) (then)
		das
	(else)
		die
	(endif)
	(name $Obj)	

(des $Obj)		
	(now) (current case #Genitiv)
	(now) (current article #Definite)
	(if) ($Obj is maskulin) (then)
		des
	(elseif) ($Obj is feminin) (then)
		der
	(elseif) ($Obj is neutrum) (then)
		des
	(else)
		der
	(endif)
	(name $Obj)
	
(dem $Obj)		
	(now) (current case #Dativ)
	(now) (current article #Definite)
	(if) ($Obj is maskulin) (then)
		dem
	(elseif) ($Obj is feminin) (then)
		der
	(elseif) ($Obj is neutrum) (then)
		dem
	(else)
		den
	(endif)
	(name $Obj)
	
(den $Obj)		
	(now) (current case #Akkusativ)
	(now) (current article #Definite)
	(if) ($Obj is maskulin) (then)
		den
	(elseif) ($Obj is feminin) (then)
		die
	(elseif) ($Obj is neutrum) (then)
		das
	(else)
		die
	(endif)
	(name $Obj)
	
(Der $Obj)	(uppercase) (der $Obj)
(Des $Obj)	(uppercase) (des $Obj)
(Dem $Obj)	(uppercase) (dem $Obj)
(Den $Obj)	(uppercase) (den $Obj)

(ihn (current player $Obj)) dich
(ihn $Obj)
	{
		($Obj is maskulin) ihn
	(or)
		($Obj is feminin) sie
	(or)
		($Obj is neutrum) es
	(or)
		sie
	}

(ihm (current player $Obj)) dir
(ihm $Obj)
	{
		($Obj is maskulin) ihm
	(or)
		($Obj is feminin) ihr
	(or)
		($Obj is neutrum) ihm
	(or)
		ihnen
	}

(ist (current player $Obj)) bist
(hat (current player $Obj)) hast

(ist $Obj)
	{
		($Obj is plural) sind
	(or)
		ist
	}

(hat $Obj)
	{
		($Obj is plural) haben
	(or)
		hat
	}

(gehört $Obj)
	{
		($Obj is plural) gehören
	(or)
		gehört
	}

(kann $Obj)	(current player $Obj) kannst 
(kann $Obj)
	{
		($Obj is plural) können 
	(or)
		kann
	}

(nimmt $Obj)	(current player $Obj) nimmst 
(nimmt $Obj)
	{
		($Obj is plural) nehmen 
	(or)
		nimmt
	}

(lässt $Obj)
	{
		($Obj is plural) lassen
	(or)
		lässt 
	}

(steigt $Obj)	(current player $Obj) steigst 
(steigt $Obj)
	{
		($Obj is plural) steigen
	(or)
		steigt 
	}

(setzt sich $Obj)	(current player $Obj) setzt dich 
(setzt sich $Obj)
	{
		($Obj is plural) setzen sich
	(or)
		setzt sich 
	}

(legt $Obj)	(current player $Obj) legst 
(legt $Obj)
	{
		($Obj is plural) legen
	(or)
		legt
	}

(schließt $Obj)
	{
		($Obj is plural) schließen
	(or)
		schließt
	}

(isst $Obj)
	{
		($Obj is plural) essen
	(or)
		isst
	}

(geht $Obj)
	{
		($Obj is plural) gehen
	(or)
		geht
	}

(sucht $Obj)
	{
		($Obj is plural) suchen
	(or)
		sucht
	}

(kommt $Obj)
	{
		($Obj is plural) kommen
	(or)
		kommt
	}

(öffnet $Obj)	(current player $Obj) öffnest 
(öffnet $Obj)
	{
		($Obj is plural) öffnen
	(or)
		öffnet
	}

(soll (current player $Obj)) sollst 
(soll $Obj)
	{
		($Obj is plural) sollen
	(or)
		soll 
	}

(muss (current player $Obj)) musst 
(muss $Obj)
	{
		($Obj is plural) müssen 
	(or)
		muss
	}

(sieht (current player $Obj)) siehst 
(sieht $Obj)
	{
		($Obj is plural) sehen 
	(or)
		sieht 
	}

(lässt sich (current player $Obj)) lässt dich 
(lässt sich $Obj)
	{
		($Obj is plural) lassen sich 
	(or)
		lässt sich 
	}

(fühlt sich (current player $Obj)) fühlst dich 
(fühlt sich $Obj)
	{
		($Obj is plural) fühlen sich 
	(or)
		fühlt sich 
	}

(fällt (current player $Obj)) fällst 
(fällt $Obj)
	{
		($Obj is plural) fallen
	(or)
		fällt
	}

(Der (current player $Obj) ist) Du bist
(Der $Obj ist)
	{
		($Obj is plural) (Der $Obj) sind
	(or)
		(Der $Obj) ist
	}

(der full $Obj)		
	(der $Obj)
	(add location information for $Obj)

(des full $Obj)		
	(des $Obj)
	(add location information for $Obj)

(dem full $Obj)		
	(dem $Obj)
	(add location information for $Obj)

(den full $Obj)		
	(den $Obj)
	(add location information for $Obj)

(ein full $Obj)		
	(ein $Obj)
	(add location information for $Obj)

(eines full $Obj)		
	(eines $Obj)
	(add location information for $Obj)

(einen full $Obj)		
	(einen $Obj)
	(add location information for $Obj)

(einem full $Obj)		
	(einem $Obj)
	(add location information for $Obj)

(er $Obj)
	{
		($Obj is maskulin) er
	(or)
		($Obj is feminin) sie
	(or)
		($Obj is neutrum) es
	(or)
		sie
	}

(er (plural $Obj)) sie
(Er $Obj) (uppercase)(er $Obj)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 9: German infinitves rewritten in known grammar forms

(understand infinitive $ as Verb $) (fail)

%% Do some rewriting to handle infinitive phrases in actor commands

(rewrite [$1 | $Words] into [$1 | $n3] )
	*(split $Words by [er sie es] into $Actor and $Right)
	*(split $Right by [soll möchte sollte könnte kann] into $ and $Order)
	*(understand infinitive $Inf as Verb $Verb)
	*(split $Order by $Inf into $Left and $)
	([$Last | $] = $Verb)
	(rewrite [$Last | $Left] into $Command )
	([soll | $Command] = $n1)
	([er | $n1] = $n2)
	(append $Actor $n2 $n3)
	(now) (current verb $1)

(rewrite [$1 | $2] into [$Last | $Rest] )
	*(understand infinitive $Inf as Verb $Verb)
	*(split $2 by $Inf into $Left and $)
	([$Last | $] = $Verb)
	($Rest = [$1 | $Left])
	(now) (current verb $Last)
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 10: Filter for German articles

(filter [der | $MoreIn] into $MoreOut)
	(just)
	(filter $MoreIn into $MoreOut)

(filter [die | $MoreIn] into $MoreOut)
	(just)
	(filter $MoreIn into $MoreOut)

(filter [das | $MoreIn] into $MoreOut)
	(just)
	(filter $MoreIn into $MoreOut)
	
(filter [den | $MoreIn] into $MoreOut)
	(just)
	(filter $MoreIn into $MoreOut)
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 11: Additional German dictionary queries

(dict $Obj)
	(fsyn $Obj)
	(msyn $Obj)
	(nsyn $Obj)
	(psyn $Obj)

(plural dict $)

(plural name $)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 12: German removable word endings

(removable word endings)
	er en es em e s es n

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 13: German noun endings in printed names

(-s)
		(current case $Case)
		(if) ($Case = #Genitiv) (then)
			(no space)s
		(endif)

(-es)
		(current case $Case)
		(if) ($Case = #Genitiv) (then)
			(no space)es
		(endif)

(-n)	
		%%Noun Endung Singular
		(current case $Case) 
		(if) ($Case = #Akkusativ) (then)
			(no space)n
		(endif)

(+n)	
		%%Noun Endung Plural
		(current case $Case) 
		(if) ($Case = #Dativ) (then)
			(no space)n
		(endif)

(-en)	
		(current case $Case) 
		(if) ($Case = #Akkusativ) (then)
			(no space)en
		(endif)

(der)
		(current case $Case) 
		(if) ($Case = #Nominativ) (then)
			der
		(elseif) ($Case = #Genitiv) (then)
			des
		(elseif) ($Case = #Genitiv) (then)
			dem
		(else) 
			den
		(endif)

(die)
		(current case $Case) 
		(if) ($Case = #Nominativ) (then)
			die
		(elseif) ($Case = #Genitiv) (then)
			der
		(elseif) ($Case = #Genitiv) (then)
			der
		(else) 
			die
		(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 14: German adjective endings in printed names
		
(er)
		%%Adjektiv Endung Maskulin
		(current case $Case)
		(current article $Article) 
		(if) ($Case = #Nominativ) (then)
		{
			(if) ($Article = #Indefinite) (then)
				(no space)er
			(else)
				(no space)e
			(endif)
		}
		(elseif) ($Case = #Genitiv) (then)
			(no space)en
		(elseif) ($Case = #Dativ) (then)
			(no space)en
		(else)
			(no space)en
		(endif)

(es)
		%%Adjektiv Endung Neutrum
		(current case $Case)
		(current article $Article) 
		(if) ($Case = #Nominativ) (then)
		{
			(if) ($Article = #Indefinite) (then)
				(no space)es
			(else)
				(no space)e
			(endif)
		}
		(elseif) ($Case = #Genitiv) (then)
			(no space)en
		(elseif) ($Case = #Dativ) (then)
			(no space)en
		(else)
		{
			(if) ($Article = #Indefinite) (then)
				(no space)es
			(else)
				(no space)e
			(endif)
		}
		(endif)

(e)
		%%Adjektiv Endung Feminin
		(current case $Case)
		(current article $Article) 
		(if) ($Case = #Nominativ) (then)
		{
			(if) ($Article = #Indefinite) (then)
				(no space)es
			(else)
				(no space)e
			(endif)
		}
		(elseif) ($Case = #Genitiv) (then)
			(no space)en
		(elseif) ($Case = #Dativ) (then)
			(no space)en
		(else)
		{
			(if) ($Article = #Indefinite) (then)
				(no space)es
			(else)
				(no space)e
			(endif)
		}
		(endif)

(e+)
		%%Adjektiv Endung Plural
		(current case $Case)
		(current article $Article)
		(if) ($Case = #Nominativ) (then)
		{
			(if) ($Article = #Indefinite) (then)
				(no space)e
			(else)
				(no space)en
			(endif)
		}
		(elseif) ($Case = #Genitiv) (then)
			(if) ($Article = #Indefinite) (then)
				(no space)er
			(else)
				(no space)en
			(endif)
		(elseif) ($Case = #Dativ) (then)
			(no space)en
		(else)
			(if) ($Article = #Indefinite) (then)
				(no space)e
			(else)
				(no space)en
			(endif)
		(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 15: Rooms and doors

(name (room $))		Ort
((room $room) is maskulin)
	~ ($room is feminin)
	~ ($room is neutrum)
	~ ($room is plural)

(room header $Room)	(Name $Room)
(look (room $R))	

(interface (from $<Room go $>Dir to room $>Obj))

%% Given a room and a direction, what room (if any) is reachable that way?
%% Given a room and a target room, what direction (if any) leads there?

(from $Here go $Dir to room $Room)
	(if) (bound $Dir) (then)
		*(from $Here go $Dir to $Target)
		(if) (room $Target) (then)
			($Target = $Room)
		(elseif) (direction $Target) (then)
			(from $Here go $Target to room $Room)
		(else)
			(door $Target)
			~($Target blocks passage)
			(from $Here through $Target to $Room)
		(endif)
	(else)
		(from $Here go $Dir to $Room)
		(or)
		(from $Here through $Door to $Room)
		(from $Here go $Dir to $Door)
	(endif)

(interface (from $<Room go $<Dir to object $>Obj))

%% Given a room and a direction, what object, door and/or room is visible
%% that way? (Usually multi-queried)

(from $Room go $Dir to object $Obj)
	(from $Room go $Dir to $Point)
	(if) (direction $Point) (then)
		*(from $Room go $Point to object $Obj)
	(elseif) (door $Point) (then)
		{
			~($Point blocks light)
			(from $Room through $Point to $Obj)
		(or)
			($Obj = $Point)
		}
	(else)
		($Obj = $Point)
	(endif)

(der (current room $))	dieser Ort

%%(name (door $))		Tür // We don't set the name of doors here and leave it up to the author
($Door blocks passage)
	($Door is closed)

($Door blocks light)
	($Door is opaque)
	($Door is closed)

@(from $Room go $Dir through $Door to $Target)
	*(from $Room go $Dir to $Door)
	*(from $Room through $Door to $Target)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 16: Access rules

(global variable (current visibility ceiling $))

(recompute visibility)
	(current player $Player)
	(visibility ceiling of $Player is $Ceil)
	(now) (current visibility ceiling $Ceil)
	(if) (light reaches ceiling $Ceil) (then)
		(now) (player can see)
	(else)
		(now) ~(player can see)
	(endif)

(recompute visibility)
	%% E.g. if there is no current player.

(interface (light reaches ceiling $<Ceil))

(light reaches ceiling (room $Ceil))
	~(inherently dark $Ceil)

(light reaches ceiling $Ceil)
	*($Obj provides light)
	(visibility ceiling of $Obj is $Ceil)

(interface (visibility ceiling of $<Obj is $>Ceil))

(visibility ceiling of $Obj is $Ceil)
	(if) ($Obj has parent $Parent) (then)
		(if)
			($Obj has relation #in)
			($Parent is opaque)
			($Parent is closed)
		(then)
			($Ceil = $Parent)
		(else)
			(visibility ceiling of $Parent is $Ceil)
		(endif)
	(else)
		($Ceil = $Obj)
	(endif)

(interface (player can see $<Obj))

(player can see $Obj)
	(current visibility ceiling $Ceil)
	(if) (visibility ceiling of $Obj is $Ceil) (then)
		{
			(player can see)
		(or)
			(current player $Player)
			($Obj has ancestor $Player)
		}
	(else)
		(room $Obj)
		(room $Ceil)
		(player can see)
		{
			(from $Ceil go $ to $Obj)
		(or)
			(from $Ceil through $Door to $Obj)
			~($Door blocks light)
		}
	(endif)

(interface (reachability ceiling of $<Obj is $>Ceil))

(reachability ceiling of $O is $Ceil)
	(if) ($O is $Rel $Parent) (then)
		(if) ($Rel = #in) ($Parent is closed) (then)
			($Parent = $Ceil)
		(else)
			(reachability ceiling of $Parent is $Ceil)
		(endif)
	(else)
		($O = $Ceil)
	(endif)

(interface (trace reachability $<Obj to $<Player or $<Ceil))

(trace reachability $Obj to $Obj or $)
(trace reachability $Obj to $ or $Obj)
(trace reachability $Obj to $Ceil1 or $Ceil2)
	($Obj is $Rel $Parent)
	(if) ($Rel = #in) ($Parent is closed) (then)
		($Parent = $Ceil2)
	(else)
		(trace reachability $Parent to $Ceil1 or $Ceil2)
	(endif)

(interface ($<Obj is reachable by $<Actor))

($Obj is reachable by $Actor)
	~(out of reach $Obj)
	(reachability ceiling of $Actor is $Ceil)
	(reachability ceiling of $Obj is $Ceil)

(interface ($<Obj is reachable by player))

($Obj is reachable by player)
	~(out of reach $Obj)
	(current player $Player)
	(reachability ceiling of $Player is $Ceil)
	(trace reachability $Obj to $Player or $Ceil)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 17: Scope

%% This predicate can be extended by the game, typically using rules that check
%% certain conditions, e.g. what the current room is:

(add $ to scope)	(fail)

%% These rules should be left as they are:

(rebuild scope)
	(recompute visibility)
	(forget pronouns out of scope)

(interface ($>Obj is in scope))

($Obj is in scope)
	*(add $Obj to scope)

($Obj is in scope)
	(if) (player can see) (then)
		(current visibility ceiling $Ceil)
		{
			*($Obj is visible up to $Ceil)
		(or)
			(room $Ceil)
			{
				*(from $Ceil go $ to $Obj)
				(room $Obj)
			(or)
				*(from $Ceil through $Door to $Obj)
				~($Door blocks light)
			}
		}
	(else)
		{
			(current visibility ceiling $Obj)
		(or)
			(current player $Player)
			*($Obj is visible up to $Player)
		}
	(endif)

(interface ($>Obj is visible up to $<Ceil))

($Obj is visible up to $Obj)

($Obj is visible up to $Ceiling)
	(if) (bound $Obj) (then)
		($Obj has parent $Parent)
		~{
			($Obj has relation #in)
			($Parent is closed)
			($Parent is opaque)
		}
		($Parent is visible up to $Ceiling)
	(else)
		(if) ($Ceiling is closed) ($Ceiling is opaque) (then)
			*($Sub has parent $Ceiling)
			~($Sub has relation #in)
		(else)
			*($Sub has parent $Ceiling)
		(endif)
		*($Obj is visible up to $Sub)
	(endif)

(scope)
	(rebuild scope)
	The current scope is: (line)
	(exhaust) {
		*($Obj is in scope)
		$Obj:
		%% Prevent (der $) from revealing hidden objects
		(if) ($Obj is hidden) (then)
			(der $Obj)
			(now) ($Obj is hidden)
		(else)
			(der $Obj)
		(endif)
		(line)
	}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 18: Select player, enter a room or other location, move floating objects

(interface (select player $<Player))

(select player $Player)
	(clear all pronouns)
	(now) (current player $Player)
	(update environment around player)

(interface (move player to $<Rel $<Loc))

(move player to $Rel $Loc)
	(current player $Player)
	(now) ($Player is $Rel $Loc)
	(update environment around player)

(interface (enter $<Room))

(enter $Room)
	(move player to #in $Room)
	(narrate entering $Room)

(interface (enter $<Room by $<Vehicle))

(enter $Room by $Vehicle)
	(now) ($Vehicle is #in $Room)
	(now) ($Vehicle is handled)
	(update environment around player)
	(narrate entering $Room)

(update environment around player)
	(if) (current player $Player) ($Player is in room $Room) (then)
		(now) (current room $Room)
		(exhaust) {
			*($Room attracts $Object)
			(now) ($Object is #in $Room)
		}
		(recompute visibility)
		(if) ($Room is unvisited) (player can see) (then)
			(now) ($Room is visited)
		(endif)
	(endif)

(narrate entering (room $))
	(par)
	(try [look])
	
(narrate entering $Obj)
	Du steigst in (den $Obj).

(narrate entering (supporter $Obj))
	Du steigst auf (den $Obj).

(narrate entering (in-seat $Obj))
	Du setzt dich in (den $Obj).

(narrate entering (on-seat $Obj))
	Du setzt dich auf (den $Obj).

(interface (prevent entering $<Obj))

(prevent entering $Obj)
	(when $Obj won't accept actor #in)

(interface (narrate failing to leave $<Obj $<Dir))

(narrate failing to leave $ $)
	In dieser Richtung scheint es keinen Ausgang zu geben.

%% Extend the following predicate to simulate objects occupying multiple rooms:

($Room attracts $Obj)
	*(from $Room go $ to $Obj)
	~(direction $Obj)
	~(room $Obj)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 19: Standard actions

%% LOOK <dir>

(describe action [look $Dir])
	nach (den $Dir) (zu) schauen

(understand infinitive [schauen/blicken/sehen] as Verb [schau])

(understand [schau/blick/sieh/seh/x | $Words] as [look $Dir])
	*(understand $Words as direction $Dir)

(understand [schau/blick/sieh/seh/x nach | $Words] as [look $Dir])
	*(understand $Words as direction $Dir)

(unlikely [look $])

(prevent [look $])
	~(player can see)
	Du kannst in der Dunkelheit nichts sehen.

(perform [look $Dir])
	(if)
		(current visibility ceiling $Room)
		(room $Room)
		(from $Room go $Dir to $Target)
	(then)
		(if) (direction $Target) (then)
			(try [look $Target])
		(elseif) (door $Target) ~($Target blocks light) (then)
			(from $Room through $Target to $OtherRoom)
			(if) ($OtherRoom is visited) (then)
				Durch (den $Target) siehst du (den $OtherRoom).
				(notice $OtherRoom)
			(else)
				Du kannst nicht erkennen, was genau auf der anderen Seite
				(des $Target) liegt.
				(notice $Target)
			(endif)
		(elseif) (room $Target) ($Target is unvisited) (then)
			Von hier aus kannst du in dieser Richtung wenig erkennen.
		(else)
			Im (name $Dir) liegt (der $Target).
			(notice $Target)
		(endif)
	(else)
		(narrate failing to look $Dir)
	(endif)

(narrate failing to look #up)
	Du siehst nichts Ungewöhnliches über dir.

(narrate failing to look #down)
	Du siehst nichts Ungewöhnliches unter dir.

(narrate failing to look #in)
	Du siehst drinnen nichts Ungewöhnliches.

(narrate failing to look #out)
	Du siehst draußen nichts Ungewöhnliches.

(narrate failing to look $)
	Du siehst in dieser Richtung nichts Ungewöhnliches.

%% LOOK <rel> <obj>

(describe action [look $Rel $Obj])
	(name $Rel) (den full $Obj) (zu) schauen

(understand [schau/blick/sieh/seh | $Words] as [look $Rel $Obj])
	*(split $Words by relation $Rel into [] and $MoreWords)
	*(understand $MoreWords as single object $Obj)

(unlikely [look #in $Obj])
	~(container $Obj)

(unlikely [look #on $Obj])
	~(supporter $Obj)

%% Reachability not required, but visibility:

(refuse [look $ $Obj])
	(just)
	{
		(when $Obj is not here)
		(or) (when $Obj is out of sight)
	}

(before [look #in $Obj])
	($Obj is opaque)
	($Obj is closed)
	(first try [open $Obj])

(instead of [look #in (current room $)])
	(try [look])

(instead of [look #in $Obj])
	{ (room $Obj) (or) (door $Obj) }
	(current room $Here)
	{
		(from $Here go $Dir to $Obj)
	(or)
		(from $Here through $Door to $Obj)
		(from $Here go $Dir to $Door)
	}
	(direction $Dir)
	(try [look $Dir])

(prevent [look #in $Obj])
	~(container $Obj)
	(Der $Obj) (kann $Obj) keine Dinge aufnehmen.

(prevent [look #in $Obj])
	($Obj is opaque)
	($Obj is closed)
	~(current visibility ceiling $Obj)
	(if) (openable $Obj) (then)
		(Der $Obj ist) geschlossen.
	(else)
		Du kannst nicht sehen, was in (dem $Obj) ist.
	(endif)

(prevent [look #behind (room $Obj)])
	Hinter (den $Obj) zu schauen bringt dich auch nicht weiter.

(perform [look $Rel $Obj])
	(collect $C)
		*($C is $Rel $Obj)
		(now) ($C is revealed)
	(into $List)
	(if) (empty $List) (then)
		(if) (#in = $Rel) (then)
			(Der $Obj ist) leer.
		(else)
			(if) ($Rel is one of [#under #behind]) (then)
				Du findest
			(else)
				Da ist
			(endif)
			nichts (name $Rel) (dem $Obj).
		(endif)
	(else)
		(Name $Rel) (dem $Obj) siehst du (einen $List). (notice $List)
	(endif)

%% FIND <obj>

%% FIND takes the player to the room that currently contains the object.
%% For objects that move around autonomously, it may be a good idea to override
%% this rule, to say e.g. "you don't know where the cat might be right now".
%% Note that floating objects, including doors, will remain in the room where
%% they were last encountered. This will usually put the player on the expected
%% side of doors.

(describe action [find $Obj])
	(den full $Obj) (zu) finden

(understand infinitive [finden] as Verb [find])
(understand infinitive [suchen] as Verb [such])

(understand [find | $Words] as [find $Obj])
	*(understand $Words as any object $Obj)
	
(understand [such nach | $Words] as [find $Obj])
	*(understand $Words as any object $Obj)

(unlikely [find $Obj])
	($Obj is nowhere)

~(refuse [find $])

(prevent [find (not here $Obj)])
	Du weißt nicht, wo sich (der $Obj) befindet.

(prevent [find $Obj])
	(when $Obj is already held)

(prevent [find $Obj])
	($Obj is in room $Room)
	(current room $Room)
	(Der $Obj ist) 
	(if) ($Obj is $Rel $Loc) ~(room $Loc) (then)
		(name $Rel) (dem $Loc)
	(else)
		hier
	(endif)
	.

(prevent [find $Obj])
	($Obj is in room $Room)
	(current room $Here)
	~(shortest path from $Here to $Room is $)
	Du weißt nicht, wie man von hier zu (dem $Obj) gelangt.

(perform [find $Obj])
	(if) ($Obj is in room $Room) (then)
		(line) \( zu (dem $Room) gehen \) (line)
		(try [go to $Room])
	(else)
		Du hast keine Ahnung, wo du (den $Obj) findest.
	(endif)

%% EXAMINE <obj>

(describe action [examine $Obj])
	(den full $Obj) (zu) untersuchen

(understand infinitive [beobachten/untersuchen/betrachten/beschreiben/anschauen/ansehen] as Verb [untersuch])

(understand [x/beobacht/beschreib/betracht/untersuch/u | $Words] as [examine $Obj])
	*(understand $Words as non-all object $Obj)

(understand [schau/sieh/seh/blick an | $Words] as [examine $Obj])
	*(understand $Words as non-all object $Obj)

(understand [wer bin ich] as [examine $Player])
	(current player $Player)

~(refuse [examine $]) %% No need for reachability.

(instead of [examine (room $Obj)])
	(current room $Here)
	~($Here = $Obj)
	(if)
		(from $Here go $Dir to $Obj)
	(then)
		(try [look $Dir])
	(elseif)
		(from $Here through $Door to $Obj)
		~($Door blocks light)
		(from $Here go $Dir to $Door)
	(then)
		(try [look $Dir])
	(else)
		Von hier aus siehst du (den $Obj) nicht so gut.
	(endif)

(perform [examine (current visibility ceiling $Obj)])
	(look $Obj)

(perform [examine $Obj])
	(descr $Obj)
	(if) (supporter $Obj) (then)
		(if) (fungibility enabled) (then)
			(collect $Child)
				*($Child is #on $Obj)
			(into $OnList)
			(fungibility-enabled appearance $OnList #on $Obj)
		(else)
			(exhaust) {
				*($Child is #on $Obj)
				(par)
				(appearance $Child #on $Obj)
				(notice $Child)
			}
		(endif)
	(endif)
	(if) (container $Obj) ~{ ($Obj is opaque) ($Obj is closed) } (then)
		(if) (fungibility enabled) (then)
			(collect $Child)
				*($Child is #in $Obj)
			(into $InList)
			(fungibility-enabled appearance $InList #in $Obj)
		(else)
			(exhaust) {
				*($Child is #in $Obj)
				(par)
				(appearance $Child #in $Obj)
				(notice $Child)
			}
		(endif)
	(endif)
	(par)

%% LOOK

(understand [l/lage/schau/blick/sieh/seh] as [look])
(understand [schau/blick/sieh/seh um dich] as [look])
(understand [wo bin ich] as [look])

(describe action [look])
	um(no space)(zu)(no space)schauen

(perform [look])
	(current player $Player)
	(current visibility ceiling $Ceil)
	(div @roomheader) (location headline)
	(if) (player can see) (then)
		(look $Ceil)
		($Player is $Rel $Loc)
		(make appearances $Rel $Loc)
		(par)
	(else)
		(narrate darkness)
	(endif)

%% SEARCH <obj>

(understand infinitive [durchsuchen/durchwühlen/durchforsten] as Verb [durchsuch])

(describe action [search $Obj])
	(den full $Obj) (zu) durchsuchen

(understand [durchsuch/durchwühl/durchforst | $Words] as [search $Obj])
	*(understand $Words as non-all object $Obj)

(instead of [search (current room $R)])
	(try [look])

(perform [search $O])
	(if) ($O is closed) ($O is opaque) (then)
		($InList = [])
	(else)
		(collect $C) *($C is #in $O) (reveal $C) (into $InList)
	(endif)
	(collect $C) *($C is #on $O) (reveal $C) (into $OnList)
	(collect $C) *($C is #behind $O) (reveal $C) (into $BehindList)
	(collect $C) *($C is #under $O) (reveal $C) (into $UnderList)
	(if) (nonempty $InList) (then)
		(if) ($InList = [$InObj]) (then)
			(Ein $InObj) (ist $InObj) in (dem $O).
		(else)
			In (dem $O) findest du (einen $InList).
		(endif)
		(notice $InList)
	(endif)
	(if) (nonempty $OnList) (then)
		(if) ($OnList = [$OnObj]) (then)
			(Ein $OnObj) (ist $OnObj) auf (dem $O).
		(else)
			Auf (dem $O) findest du (einen $OnList).
		(endif)
		(notice $OnList)
	(endif)
	(if) (nonempty $BehindList) (then)
		Du entdeckst (einen $BehindList) hinter (dem $O).
		(notice $BehindList)
	(endif)
	(if) (nonempty $UnderList) (then)
		Du entdeckst (einen $UnderList) unter (dem $O).
		(notice $UnderList)
	(endif)
	(if)
		(empty $InList)
		(empty $OnList)
		(empty $BehindList)
		(empty $UnderList)
	(then)
		Du findest nichts interessantes.
	(endif)

%% FEEL <obj>

(describe action [feel $Obj])
	(den full $Obj) an(no space)(zu)(no space)fühlen

(understand infinitive [betasten/berühren/fühlen/tasten/antasten] as Verb [fühl])

(understand [fühl/reib/tast/rühr an | $Words] as [feel $Obj])
	*(understand $Words as non-all object $Obj)

(understand [fühl/reib/tast/betast/berühr | $Words] as [feel $Obj])
	*(understand $Words as non-all object $Obj)

(perform [feel $Obj])
	(feel $Obj)

%% LISTEN TO <obj>
%% LISTEN

(describe action [listen to $Obj])
	(dem full $Obj) zu(no space)(zu)(no space)hören

(describe action [listen])
	zu(no space)(zu)(no space)hören

(understand infinitive [lauschen/zuhören/anhören] as Verb [hör])

(understand [hör] as [listen])
(understand [hör zu] as [listen])

(understand [hör/lausch/horch | $Words] as [listen to $Obj])
	*(understand $Words as single object $Obj)

(understand [hör/lausch/horch an/zu | $Words] as [listen to $Obj])
	*(understand $Words as single object $Obj)

%% Don't require reachability:

(refuse [listen to $Obj])
	(just) (when $Obj is not here)

(perform [listen to $Obj])
	(if) (current player $Obj) (then)
		Dein Blut rauscht dir in den Ohren und du spürst ein
		schwaches Aufbäumen deiner Nerven.
	(elseif) (animate $Obj) (then)
		(Der $Obj) (ist $Obj) still.
	(elseif) (room $Obj) (then)
		Du hörst nichts Ungewöhnliches.
	(else)
		Du hörst nichts Ungewöhnliches von (dem $Obj).
	(endif)

(understand [lausch/horch/hör] as [listen])
(understand [hör zu] as [listen])

(instead of [listen])
	(current room $Room)
	(try [listen to $Room])

%% KISS <obj>

(describe action [kiss $Obj])
	(den full $Obj) (zu) küssen

(understand infinitive [umarmen/küssen/lieben] as Verb [küss])

(rewrite [umarm/lieb | $Words] into [küss | $Words])

(understand [küss | $Words] as [kiss $Obj])
	*(understand $Words as single object $Obj preferably animate)

(prevent [kiss $Obj])
	(current player $Player)
	{
		($Obj = $Player)
	(or)
		($Obj is part of $Player)
	}
	Deine Gefühle sind vorwiegend platonischer Art.

(perform [kiss $Obj])
	(Der $Obj ist) von deiner Zuneigung sichtlich unbeeindruckt.

%% JUMP

(describe action [jump])
	(zu) springen

(understand infinitive [hüpfen/springen] as Verb [spring])

(understand [spring/übe/hüpf] as [jump])

(perform [jump])
	Du springst ein wenig auf der Stelle.

%% DANCE

(describe action [dance])
	(zu) tanzen

(understand infinitive [tanzen] as Verb [tanz])
(understand infinitive [drehen] as Verb [dreh])
(understand infinitive [bewegen] as Verb [beweg])

(rewrite [beweg/dreh dich] into [tanz])
(rewrite [wirbel herum] into [dance])

(understand [tanz] as [dance])

(perform [dance])
	Du übst deine Moves.

%% WAVE <obj>
%% WAVE

(describe action [wave $Obj])
	mit (dem $Obj) (zu) winken

(describe action [wave])
	(zu) winken

(understand infinitive [schütteln] as Verb [schüttel])
(understand infinitive [winken] as Verb [wink])

(understand [schüttl | $Words] as [schüttel $Obj])
	*(understand $Words as object $Obj preferably held)

(unlikely [wave $Obj])
	(current player $Player)
	~($Obj is #heldby $Player)
	~($Obj is part of $Player)

(before [wave $Obj])
	(ensure $Obj is held)

(prevent [wave $Obj])
	(current player $Player)
	~($Obj is part of $Player)
	(when $Obj isn't directly held)

(perform [wave $Obj])
	Du schüttelst (den $Obj), ohne erkennbare Veränderung.

(understand [schüttel dich] as [wave])
(understand [wink] as [wave])

(perform [wave])
	Du schüttelst deine Hände in die Luft.

%% SING

(describe action [sing])
	(zu) singen

(understand infinitive [summen/singen] as Verb [sing])

(understand [sing/summ] as [sing])

(perform [sing])
	Du summst ein paar Takte.

%% THROW <obj> AT <obj>
%% THROW <obj>
%% THROW <obj> <dir>

(describe action [throw $Obj at $Dest])
	(den full $Obj) auf (den $Dest) (zu) werfen

(describe action [throw $Obj])
	(den full $Obj) (zu) werfen

(describe action [throw $Obj $Dir])
	(den full $Obj) nach (dem $Dir) (zu) werfen

(understand infinitive [werfen] as Verb [werf])

(understand [werf/wirf | $Words] as [throw $A at $B])
	*(split $Words by [auf gegen in] into $Left and $Right)
	*(understand $Left as object $A preferably held)
	*(understand $Right as single object $B)

(understand [werf/wirf | $Words] as [throw $Obj])
	*(understand $Words as object $Obj preferably held)

(understand [werf/wirf weg | $Words] as [throw $Obj])
	*(understand $Words as object $Obj preferably held)

(understand [werf/wirf | $Words] as [throw $Obj $Dir])
	(split $Words by [gen nach] into $Left and $Right)
	(parse direction $Right $Dir)
	*(understand $Left as object $Obj preferably held)

(unlikely [throw $Obj | $])
	(current player $Actor)
	~($Obj has ancestor $Actor)

(perform [throw $Obj])
	Worauf?
	(asking for object in [throw $Obj at []])

(instead of [throw $Obj $Dir])
	(current room $Here)
	(if) (from $Here go $Dir to object $Target) (then)
		(try [throw $Obj at $Target])
	(else)
		(try [throw $Obj])
	(endif)

%% The target doesn't have to be reachable:

(refuse [throw $Obj at $Target])
	(just)
	{
		(when $Obj is not here)
		(or) (when $Target is not here)
		(or) (when $Obj is out of reach)
	}

(before [throw $Obj at $])
	(current player $Actor)
	($Obj has ancestor $Actor)
	(ensure $Obj is held)

(prevent [throw $Obj at $])
	~(current player $Obj)
	(when $Obj isn't directly held)

(perform [throw $Obj at $Target])
	(Den $Obj) auf (den $Target) zu werfen wird dich nicht weiter bringen.
	(tick) (stop)

%% THINK

(describe action [think])
	nach(no space)(zu)(no space)denken

(understand infinitive [denken/überlegen/nachdenken] as Verb [denk])

(understand [denk] as [think])
(understand [überleg] as [think])
(understand [denk nach] as [think])

(perform [think])
	Das wäre schon mal ein Anfang.
	(line) \( Versuch es mit HINWEIS, wenn du verzweifelt bist. \) (line)

%% SLEEP

(describe action [sleep])
	(zu) schlafen

(understand infinitive [schlafen/träumen/einschlafen] as Verb [schlaf])

(understand [schlaf] as [sleep])
(understand [mach ein nickerchen] as [sleep])
(understand [schlaf ein] as [sleep])
(understand [träum] as [sleep])

(perform [sleep])
	Du bist nicht müde.

%% TAKE <obj>
%% TAKE <obj> FROM <obj>

(describe action [take $Obj])
	(den full $Obj) (zu) nehmen

(describe action [take $Obj $Rel $Holder])
	(den full $Obj) (reverse-name $Rel) (dem $Holder) (zu) nehmen

(understand infinitive [nehmen/aufheben/mitnehmen/schnappen/greifen] as Verb [nimm])

(understand [nimm/nehm/greif/schnapp | $Words] as [take $Obj])
	*(understand $Words as object $Obj preferably takable)

(understand [nimm/nehm/greif/schnapp dir | $Words] as [take $Obj])
	*(understand $Words as object $Obj preferably takable)

(understand [nimm/nehm mit | $Words] as [take $Obj])
	*(understand $Words as object $Obj preferably takable)

(understand [heb auf | $Words] as [take $Obj])
	*(understand $Words as object $Obj preferably takable)

(understand [nimm/nehm/greif/schnapp | $Words] as [take $Obj from $Parent])
	*(split $Words by [von aus in] into $Left and $Right)
	*(understand $Right as single object $Parent)
	*(understand $Left as object $Obj preferably child of $Parent)

(unlikely [take $Obj])
	~(item $Obj) (or) ($Obj has relation $Rel) ($Rel is one of [#partof #heldby #wornby])

(unlikely [take $Obj from $Parent])
	~($Obj has ancestor $Parent)

(prevent [take $Obj from $Parent])
	~($Obj has ancestor $Parent)
	(if) (animate $Parent) (then)
		(Der $Parent) (hat $Parent) (den $Obj) nicht.
	(elseif) (container $Parent) (then)
		(Der $Obj ist) nicht in (dem $Parent).
	(elseif) (supporter $Parent) (then)
		(Der $Obj ist) nicht auf (dem $Parent).
	(else)
		(Der $Obj ist) woanders.
	(endif)

(perform [take $Obj from $Parent])
	(current player $Player)
	($Obj is recursively worn by $Player)
	{
		($Parent = $Player)
	(or)
		($Parent has ancestor $Player)
	}
	(try [remove $Obj])

(perform [take $Obj from $])
	(try [take $Obj])

(prevent [take $Obj])
	(when $Obj is already held)
	(or) (when $Obj is fine where it is)
	(or) (when $Obj is part of something)
	(or) (when $Obj is held by someone)
	(or) (when $Obj is worn by someone)
	(or) (when $Obj can't be taken)

(narrate taking $Obj)
	(current player $Actor)
	Du nimmst (den $Obj)
	(if) ($Obj is $Rel $Parent) ~($Actor has ancestor $Parent) (then)
		(reverse-name $Rel) (dem $Parent)
	(endif)
	.

(perform [take $Obj])
	(narrate taking $Obj)
	(current player $Actor)
	(now) ($Obj is #heldby $Actor)
	(now) ($Obj is handled)

%% REMOVE <obj>

(describe action [remove $Obj])
	(den full $Obj) (zu) entfernen

(understand infinitive [lassen] as Verb [lass])
(understand infinitive [ziehen] as Verb [zieh])
(understand infinitive [ausziehen] as Verb [entfern])

(understand [lass fallen | $Words] as [remove $Obj])
	*(understand $Words as single object $Obj)
	($Obj has relation #wornby)

(understand [setz/leg ab | $Words] as [remove $Obj])
	*(understand $Words as single object $Obj)
	($Obj has relation #wornby)

(understand [zieh aus | $Words] as [remove $Obj])
	*(understand $Words as single object $Obj)
	($Obj has relation #wornby)

(understand [entfern | $Words] as [remove $Obj])
	*(understand $Words as single object $Obj)
	($Obj has relation #wornby)

(unlikely [remove $Obj])
	(current player $Actor)
	~($Obj is #wornby $Actor)

(instead of [remove $Obj])
	~(wearable $Obj)
	~($Obj has relation #partof)
	(item $Obj)
	(try [take $Obj])

(prevent [remove $Obj])
	(when $Obj is part of something)

(prevent [remove $Obj])
	(current player $Actor)
	~($Obj is recursively worn by $Actor)
	Aber du hast (den $Obj) gar nicht angezogen.

(narrate removing $Obj)
	Du ziehst (den $Obj) aus.

(perform [remove $Obj])
	(narrate removing $Obj)
	(current player $Actor)
	(now) ($Obj is #heldby $Actor)
	(now) ($Obj is handled)

%% WEAR <obj>

(describe action [wear $Obj])
	(den full $Obj) an(no space)(zu)(no space)ziehen

(understand infinitive [tragen/anziehen/anlegen] as Verb [trag])

(rewrite [trage | $Words] into [trag | $Words])

(understand [trag | $Words] as [wear $Obj])
	*(understand $Words as object $Obj preferably held)

(understand [zieh/leg an | $Words] as [wear $Obj])
	*(understand $Words as object $Obj preferably held)

(unlikely [wear $Obj])
	~(wearable $Obj)

(unlikely [wear $Obj])
	(current player $Actor)
	($Obj is #wornby $Actor)

(before [wear $Obj])
	(wearable $Obj)
	(current player $Actor)
	~($Obj is nested #wornby $Actor)
	(ensure $Obj is held)

(prevent [wear $Obj])
	(current player $Actor)
	($Obj is recursively worn by $Actor)
	Du trägst (den $Obj) schon.

(prevent [wear $Obj])
	~(wearable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht anziehen.

(prevent [wear $Obj])
	(when $Obj isn't directly held)

(narrate wearing $Obj)
	Du ziehst (den $Obj) an.

(perform [wear $Obj])
	(narrate wearing $Obj)
	(current player $Actor)
	(now) ($Obj is #wornby $Actor)
	(now) ($Obj is handled)

%% PUT <obj> <rel> <obj>

(describe action [put $Obj $Rel $Dest])
	(den full $Obj) (name $Rel) (den $Dest) (zu) (verb)

(understand infinitive [legen/plazieren] as Verb [leg])

(understand [leg/setz/stell/plazier | $Words] as [put $Obj $Rel $Dest])
	*(split $Words by relation $Rel into $Left and $Right)
	*(understand $Right as single object $Dest)
	*(understand $Left as object $Obj preferably held excluding $Dest)

(unlikely [put $Obj $ $])
	(current player $Actor)
	~($Obj has ancestor $Actor)

(unlikely [put $ #on $Dest])
	~(supporter $Dest)

(unlikely [put $ #in $Dest])
	~(container $Dest)

(unlikely [put $Obj $ $Obj])

(unlikely [put $Obj $ $Dest])
	($Dest has ancestor $Obj)

(before [put $Obj $Rel $Dest])
	~($Obj is $Rel $Dest)
	(ensure $Obj is held)

(before [put $ #in $Dest])
	($Dest is closed)
	(first try [open $Dest])

(instead of [put (current player $) #in $Dest])
	(try [enter $Dest])

(instead of [put (current player $) #on $Dest])
	(try [climb $Dest])

(instead of [put $Obj $Rel $Dest])
	(current player $Player)
	($Player is $Rel $Dest)
	(try [drop $Obj])

(prevent [put $Obj $Rel $Dest])
	(when $Obj is already $Rel $Dest)
	(or) (when $Obj isn't directly held)

(prevent [put $Obj $Rel $Dest])
	($Dest is nested $OldRel $Obj)
	Du kannst (den $Obj) nicht
	(if) ~($OldRel is one of [#in #on]) (then)
		(name $Rel) etwas legen, das sich (name $Rel) 
		(ihm $Obj) selbst befindet. 
	(else)
	(present-name $OldRel) (den $Obj) legen.
	(endif)

(prevent [put $Obj $Rel $Obj])
	Du kannst (den $Obj) nicht (name $Rel) (den $Obj) legen.

(prevent [put $ $Rel $Dest])
	(when $Dest won't accept $Rel)

(prevent [put $ #in $Dest])
	(when $Dest is closed)

(narrate putting $Obj $Rel $Dest)
	Du legst (den $Obj) (name $Rel) (den $Dest).

(perform [put $Obj $Rel $Dest])
	(narrate putting $Obj $Rel $Dest)
	(now) ($Obj is $Rel $Dest)
	(now) ($Obj is handled)

%% DROP <obj>

(describe action [drop $Obj])
	(den full $Obj) hin(no space)(zu)(no space)legen

(understand infinitive [ablegen/hinstellen/weglegen/hinlegen] as Verb [lass])

(understand [leg | $Words] as [drop $Obj])
	*(understand $Words as object $Obj preferably held)

(understand [leg/stell hin/ab/weg | $Words] as [drop $Obj])
	*(understand $Words as object $Obj preferably held)

(understand [lass fallen | $Words] as [drop $Obj])
	*(understand $Words as object $Obj preferably held)

(very unlikely [drop $Obj])
	(current player $Actor)
	~($Obj is #heldby $Actor)

(unlikely [drop $Obj])
	(current player $Actor)
	~($Obj has ancestor $Actor)

(before [drop $Obj])
	(current player $Actor)
	($Obj has ancestor $Actor)
	~($Obj has relation #partof)
	(ensure $Obj is held)

(prevent [drop $Obj])
	(when $Obj is part of something)
	(or) (when $Obj isn't directly held)

(narrate dropping $Obj)
	(current player $Actor)
	($Actor is $Rel $Loc)
	(Der $Obj) (fällt $Obj)
	(if) ($Rel = #on) (then)
		auf (den $Loc).
	(else)
		auf den Boden.
	(endif)

(perform [drop $Obj])
	(narrate dropping $Obj)
	(current player $Actor)
	($Actor is $Rel $Loc)
	(now) ($Obj is $Rel $Loc)
	(now) ($Obj is handled)

%% INVENTORY

(describe action [inventory])
	das Inventar (zu) betrachten

(understand [inventar/i/inv] as [inventory])
(understand [was hab ich] as [inventory])
(understand [was hab ich dabei] as [inventory])
(understand [betracht inventar] as [inventory])

(perform [inventory])
	(current player $Player)
	(collect $C) *($C is #heldby $Player) (into $HeldList)
	(collect $C) *($C is #wornby $Player) (into $WornList)
	Du hast
	(if) (empty $HeldList) (then)
		(narrate holding nothing)
	(else)
		(einen $HeldList)
	(endif)
	(if) (empty $WornList) (then)
		(narrate wearing nothing)
	(else)
		. Du hast (einen $WornList) angezogen
	(endif)
	. (line)

(narrate holding nothing)
	nichts dabei

(narrate wearing nothing)

%% EXITS

(describe action [exits])
	die Äusgänge an(no space)(zu)(no space)zeigen

(understand [ausgänge/ausgang] as [exits])
(understand [zeig mir den ausgang] as [exits])
(understand [zeig mir die ausgänge] as [exits])
(understand [zeig ausgang] as [exits])
(understand [zeig ausgänge] as [exits])
(understand [map/karte] as [exits])

(prevent [exits])
	~(player can see)
	In dieser Dunkelheit bist du nicht sicher, wo sich die Ausgänge genau befinden.

(perform [exits])
	(current room $Room)
	(if)
		~{
			*(from $Room go $Dir to $Target)
			(direction $Dir)
			{ (room $Target) (or) (door $Target) }
		}
	(then)
		Es gibt keine erkennbaren Ausgänge.
	(else)
		Ausgänge: (uppercase)
		(exhaust) {
			*(from $Room go $Dir to $Target)
			(select) 
			(or)
				,
			(stopping)
			(direction $Dir)
			(if) (door $Target) (then)
				(Name $Dir)
				durch (den $Target)
				(if) ($Target is closed) (then)
					\(momentan geschlossen\)
				(elseif)
					(from $Room through $Target to $R)
					($R is visited)
				(then)
					nach
					(if) (inherently dark $R) (then)
						, in die Dunkelheit
					(else)
						, zu (dem $R)
					(endif)
				(endif)
			(elseif) (room $Target) (then)
				nach
				(if) ($Dir = #in) (then)
					drinnen
				(else)
					(Name $Dir)
				(endif)
				(if) ($Target is visited) (then)
					(if) (inherently dark $Target) (then)
						, in völlige Dunkelheit
					(else)
						, zu (dem $Target)
					(endif)
				(endif)
			(endif)
		}
		.
	(endif)

%% EXIST (misspelled EXITS, just for the giggles)

(understand [cogito ergo sum] as [exist])
(understand [ich denke also bin ich] as [exist])

(perform [exist])
	Genau.

%% WAIT

(describe action [wait])
	(zu) warten

(understand infinitive [warten/chillen] as Verb [wart])

(rewrite [z/wart/chill] into [wart])

(understand [wart] as [wait])

(perform [wait])
	Ein Moment verstreicht.

%% GIVE <obj> TO <obj>
%% GIVE <obj>

(describe action [give $Obj to $Dest])
	(den full $Obj) (dem $Dest) (zu) geben

(describe action [give $Obj])
	(den full $Obj) weg(no space)(zu)(no space)geben

(understand infinitive [geben/übergeben] as Verb [gib])

(understand [übergib/übergeb/geb/gib | $Words] as [give $Obj to $Dest])
	*(split $Words by [an dem der] into $Left and $Right)
	*(understand $Right as single object $Dest preferably animate)
	*(understand $Left as object $Obj preferably held excluding $Dest)

(understand [übergib/übergeb/geb/gib | $Words] as [give $Obj to $Dest])
	*(split $Words anywhere into $Left and $Right)
	*(understand $Left as single object $Dest preferably animate)
	*(understand $Right as object $Obj preferably held excluding $Dest)

(understand [übergib/übergeb/geb/gib | $Words] as [give $Obj to $Dest])
	*(split $Words anywhere into $Left and $Right)
	*(understand $Right as single object $Dest preferably animate)
	*(understand $Left as object $Obj preferably held excluding $Dest)

(understand [übergib/übergeb/geb/gib | $Words] as [give $Obj])
	*(understand $Words as object $Obj preferably held)

(unlikely [give $Obj to $Obj])

(unlikely [give $Obj to $])
	(current player $Player)
	~($Obj has ancestor $Player)

(unlikely [give $ to $Dest])
	~(animate $Dest)

(unlikely [give $])

(perform [give $Obj])
	To whom?
	(asking for object in [give $Obj to []])

(before [give $Obj to $])
	(ensure $Obj is held)

(prevent [give $Obj to $])
	(when $Obj isn't directly held)

(perform [give $ to $Dest])
	(if) (animate $Dest) (then)
		(Der $Dest ist) daran nicht interessiert.
	(else)
		(Einem $Dest) kannst du keine Dinge geben.
	(endif)
	(tick) (stop)

%% SHOW <obj> TO <obj>
%% SHOW <obj>

(describe action [show $Obj to $Dest])
	(den full $Obj) (dem $Dest) (zu) zeigen

(describe action [show $Obj])
	(den full $Obj) her(no space)(zu)(no space)zeigen

(understand infinitive [zeigen] as Verb [zeig])

(understand [zeig | $Words] as [show $Obj to $Dest])
	*(split $Words anywhere into $Left and $Right)
	*(understand $Left as single object $Dest preferably animate)
	*(understand $Right as object $Obj preferably held excluding $Dest)

(understand [zeig | $Words] as [show $Obj])
	*(understand $Words as object $Obj preferably held)

(unlikely [show $Obj to $Obj])

(unlikely [show $Obj to $])
	(item $Obj)
	(current player $Actor)
	~($Obj is nested #heldby $Actor)

(unlikely [show $ to $Dest])
	~(animate $Dest)

(unlikely [show $])

(refuse [show $Obj to $Person])
	(just)
	{
		(when $Obj is not here)
		(or) (when $Person is not here)
		(or) (when $Obj is out of reach)
	}

(perform [show $Obj])
	Wem?
	(asking for object in [show $Obj to []])

(before [show $Obj to $])
	(item $Obj)
	(ensure $Obj is held)

(prevent [show $Obj to $])
	(item $Obj)
	(when $Obj isn't directly held)

(perform [show $ to $Dest])
	(if) (animate $Dest) (then)
		(Der $Dest ist) scheinbar nicht interessiert daran.
	(else)
		(Dem $Dest) Dinge zu zeigen bringt nichts.
	(endif)
	(tick) (stop)

%% OPEN <obj>

(describe action [open $Obj])
	(den full $Obj) (zu) öffnen

(understand infinitive [öffnen/aufmachen] as Verb [öffne])

(understand [öffne | $Words] as [open $Obj])
	*(understand $Words as non-all object $Obj)

(understand [mach auf | $Words] as [open $Obj])
	*(understand $Words as non-all object $Obj)

(understand [pack aus | $Words] as [open $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [open $Obj])
	~(openable $Obj) (or) ($Obj is open)

(before [open $Obj])
	($Obj is closed)
	($Obj is locked)
	(current player $Player)
	*($Key is nested #heldby $Player)
	($Key unlocks $Obj)
	~($Key is hidden)
	(first try [unlock $Obj with $Key])

(prevent [open $Obj])
	~(openable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht öffnen.

(prevent [open (openable $Obj)])
	($Obj is open)
	(Der $Obj ist) schon offen.

(prevent [open $Obj])
	($Obj is locked)
	(Der $Obj ist) verschlossen.

(narrate opening $Obj)
	Du öffnest (den $Obj)
	(collect $Child)
		*($Child is #in $Obj)
		(reveal $Child)
	(into $List)
	(if) (nonempty $List) (then)
		und entdeckst (einen $List)
		(notice $List)
	(endif)
	.

(perform [open $Obj])
	(narrate opening $Obj)
	(now) ($Obj is open)

%% CLOSE <obj>

(describe action [close $Obj])
	(den full $Obj) (zu) schließen

(understand infinitive [schließen/zumachen] as Verb [schließ])

(understand [mach zu | $Words] as [close $Obj])
	*(understand $Words as non-all object $Obj)

(understand [pack ein | $Words] as [close $Obj])
	*(understand $Words as non-all object $Obj)

(understand [schließ | $Words] as [close $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [close $Obj])
	~(openable $Obj) (or) ($Obj is closed)

(prevent [close $Obj])
	~(openable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht schließen.

(prevent [close $Obj])
	($Obj is closed)
	(Der $Obj ist) schon geschlossen.

(narrate closing $Obj)
	Du schließt (den $Obj).

(perform [close $Obj])
	(narrate closing $Obj)
	(now) ($Obj is closed)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% UNLOCK <obj> WITH <obj>
%% UNLOCK <obj>

(describe action [unlock $Obj with $Key])
	(den full $Obj) mit (dem $Key) auf(no space)(zu)(no space)schließen

(describe action [unlock $Obj])
	(den full $Obj) auf(no space)(zu)(no space)schließen

(understand infinitive [aufschließen/aufsperren] as Verb [öffne])

(understand [öffne | $Words] as [unlock $Obj with $Key])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $Obj)
	*(understand $Right as single object $Key preferably held)

(understand [schließ/mach/sperr auf | $Words] as [unlock $Obj with $Key])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $Obj)
	*(understand $Right as single object $Key preferably held)

(understand [schließ/sperr auf | $Words] as [unlock $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [unlock $Obj | $])
	~(lockable $Obj) (or) ($Obj is unlocked)

(before [unlock $ with $Key])
	(ensure $Key is held)

(instead of [unlock $Obj])
	(current player $Player)
	*($Key is nested #heldby $Player)
	($Key unlocks $Obj)
	~($Key is hidden)
	(line) \(mit (dem $Key)\) (line)
	(try [unlock $Obj with $Key])

(prevent [unlock $Obj | $])
	~(lockable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht aufschließen.

(prevent [unlock (lockable $Obj) | $])
	($Obj is unlocked)
	(Der $Obj ist) schon aufgeschlossen.

(perform [unlock $Obj])
	Womit?
	(asking for object in [unlock $Obj with []])

(prevent [unlock $Obj with $Key])
	~($Key unlocks $Obj)
	(Der $Obj) (lässt sich $Obj) nicht mit (dem $Key) öffnen.

(narrate unlocking $Obj with $Key)
	Du öffnest (den $Obj) mit (dem $Key).

(perform [unlock $Obj with $Key])
	(narrate unlocking $Obj with $Key)
	(now) ($Obj is unlocked)

%% LOCK <obj> WITH <obj>
%% LOCK <obj>

(describe action [lock $Obj with $Key])
	(den full $Obj) mit (dem $Key) ab(no space)(zu)(no space)schließen

(describe action [lock $Obj])
	(den full $Obj) abs(no space)(zu)(no space)chließen

(understand infinitive [verspererren/verschließen/absperren/abschließen] as Verb [verschließ])

(rewrite [versperr | $Words] into [verschließ | $Words])

(understand [schließ/mach/sperr ab/zu | $Words] as [lock $Obj with $Key])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $Obj)
	*(understand $Right as single object $Key preferably held)

(understand [schließ | $Words] as [lock $Obj with $Key])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $Obj)
	*(understand $Right as single object $Key preferably held)

(understand [verschließ/versperr | $Words] as [lock $Obj])
	*(understand $Words as non-all object $Obj)

(understand [schließ/mach/sperr ab/zu | $Words] as [lock $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [lock $Obj | $])
	~(lockable $Obj)
	(or) ($Obj is locked)

(before [lock $ with $Key])
	(ensure $Key is held)

(instead of [lock $Obj])
	(current player $Player)
	*($Key is nested #heldby $Player)
	($Key unlocks $Obj)
	~($Key is hidden)
	(line) \(mit (dem $Key)\) (line)
	(try [lock $Obj with $Key])

(prevent [lock $Obj | $])
	~(lockable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht verschließen.

(prevent [lock (lockable $Obj) | $])
	($Obj is locked)
	(Der $Obj ist) schon verschlossen.

(perform [lock $Obj])
	Womit?
	(asking for object in [lock $Obj with []])

(prevent [lock $Obj with $Key])
	~($Key unlocks $Obj)
	(Der $Obj) (lässt sich $Obj) nicht mit (dem $Key) abschließen.

(narrate locking $Obj with $Key)
	Du schließt (den $Obj) mit (dem $Key) ab.

(perform [lock $Obj with $Key])
	(narrate locking $Obj with $Key)
	(now) ($Obj is locked)

%% SWITCH ON <obj>

(describe action [switch on $Obj])
	(den full $Obj) an(no space)(zu)(no space)schalten

(understand infinitive [einschalten/anschalten/aktivieren] as Verb [aktivier])

(understand [stell/dreh/schalt/mach an/ein | $Words] as [switch on $Obj])
	*(understand $Words as non-all object $Obj)

(understand [aktivier | $Words] as [switch on $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [switch on $Obj])
	~(switchable $Obj) (or) ($Obj is on)

(describe action [switch on $Obj])
	(den full $Obj) an(no space)(zu)(no space)zuschalten

(prevent [switch on $Obj])
	~(switchable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht anschalten.

(prevent [switch on $Obj])
	($Obj is on)
	(Der $Obj ist) schon an.

(narrate switching on $Obj)
	Du schaltest (den $Obj) an.

(perform [switch on $Obj])
	(narrate switching on $Obj)
	(now) ($Obj is on)

%% SWITCH OFF <obj>

(describe action [switch off $Obj])
	(den full $Obj) ab(no space)(zu)(no space)schalten

(understand infinitive [abschalten/ausschalten/deaktivieren] as Verb [deaktivier])

(understand [stell/dreh/schalt/mach ab/aus | $Words] as [switch off $Obj])
	*(understand $Words as non-all object $Obj)

(understand [deaktivier | $Words] as [switch off $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [switch off $Obj])
	~(switchable $Obj) (or) ($Obj is off)

(describe action [switch off $Obj])
	(den full $Obj) aus(no space)(zu)(no space)schalten

(prevent [switch off $Obj])
	($Obj is off)
	(Der $Obj ist) schon aus.

(prevent [switch off $Obj])
	~(switchable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht ausschalten.

(narrate switching off $Obj)
	Du schaltest (den $Obj) aus.

(perform [switch off $Obj])
	(narrate switching off $Obj)
	(now) ($Obj is off)

%% SQUEEZE <obj>

(describe action [squeeze $Obj])
	(den full $Obj) (zu) zerdrücken

(understand infinitive [zerdrücken/zerquetschen/quetschen/ausquetschen/ausdrücken] as Verb [quetsch])

(understand [zerdrück/quetsch | $Words] as [squeeze $Obj])
	*(understand $Words as non-all object $Obj)

(understand [drück/quetsch aus| $Words] as [squeeze $Obj])
	*(understand $Words as non-all object $Obj)

(perform [squeeze $Obj])
	Du gibst (dem $Obj) einen festen Druck.

%% FIX <obj>

(describe action [fix $Obj])
	(den full $Obj) (zu) reparieren

(understand infinitive [reparieren/restaurieren] as Verb [reparier])

(understand [reparier/restaurier | $Words] as [fix $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [fix $Obj])
	($Obj is in order)

(prevent [fix $Obj])
	($Obj is in order)
	Du kannst an (dem $Obj) keinen Fehler feststellen.

(perform [fix $Obj])
	Du hast keine Ahnung, ob sich (der $Obj) reparieren lässt.
	(tick) (stop)

%% TASTE <obj>

(describe action [taste $Obj])
	(den full $Obj) (zu) probieren

(understand infinitive [lecken/schlecken/probieren] as Verb [probier])

(understand [leck/schleck/probier | $Words] as [taste $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [taste $Obj])
	~(edible $Obj)
	~(potable $Obj)

(prevent [taste $Obj])
	~(edible $Obj)
	~(potable $Obj)
	Igitt!

(perform [taste $Obj])
	Du genießt den Geschmack (des $Obj).

%% FLY

(describe action [fly])
	(zu) fliegen

(understand infinitive [fliegen/schweben] as Verb [schweb])

(understand [schweb/flieg] as [fly])

(perform [fly])
	Dir fehlt die Fähigkeit dazu.

%% BITE <obj>

(describe action [bite $Obj])
	in (den $Obj) (zu) beißen

(understand infinitive [kauen/beißen] as Verb [beiß])

(rewrite [kau | $Words] into [beiß | $Words])
(rewrite [kau an | $Words] into [beiß | $Words])
(rewrite [beiß in | $Words] into [beiß | $Words])

(understand [beiß | $Words] as [bite $Obj])
	*(understand $Words as single object $Obj)

(perform [bite (animate $Obj)])
	(try [attack $Obj])

(perform [bite $Obj])
	(try [eat $Obj])

%% EAT <obj>

(describe action [eat $Obj])
	(den full $Obj) (zu) essen

(understand infinitive [essen/verschlingen/aufessen] as Verb [iss])

(understand [ess/verschling/iss | $Words] as [eat $Obj])
	*(understand $Words as non-all object $Obj)

(understand [ess/verschling/iss auf | $Words] as [eat $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [eat $Obj])
	~(edible $Obj)
	~(potable $Obj)

(before [eat $Obj])
	(item $Obj)
	(ensure $Obj is held)

(instead of [eat $Obj])
	~(edible $Obj)
	(potable $Obj)
	(try [drink $Obj])

(prevent [eat $Obj])
	(current player $Player)
	{
		($Obj = $Player)
	(or)
		($Obj is part of $Player)
	}
	Kannibalismus ist hier nicht die Lösung.

(prevent [eat $Obj])
	~(edible $Obj)
	(Der $Obj ist) ungenießbar.

(prevent [eat $Obj])
	(item $Obj)
	(when $Obj isn't directly held)

(narrate eating $Obj)
	Du isst (den $Obj).

(perform [eat $Obj])
	(narrate eating $Obj)
	(now) ($Obj is nowhere)
	(now) ($Obj is handled)

%% DRINK <obj>

(describe action [drink $Obj])
	(den full $Obj) (zu) trinken

(understand infinitive [trinken/schlucken/verschlucken/nippen/schlürfen] as Verb [trink])

(rewrite [nipp/schluck/verschluck/schlürf | $Words] into [trink | $Words])

(understand [nipp/schluck/verschluck/schlürf/trink | $Words] as [drink $Obj])
	*(understand $Words as non-all object $Obj)

(understand [nipp/trink an | $Words] as [drink $Obj])
	*(understand $Words as non-all object $Obj)

(understand [trink aus | $Words] as [drink $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [drink $Obj])
	~(potable $Obj)

(before [drink $Obj])
	(item $Obj)
	(ensure $Obj is held)

(prevent [drink $Obj])
	~(potable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht trinken.

(prevent [drink $Obj])
	(item $Obj)
	(when $Obj isn't directly held)

(perform [drink $Obj])
	Du genießt einen Schluck von (den $Obj).

%% CUT <obj> WITH <obj>
%% CUT <obj>

(describe action [cut $Obj with $Tool])
	(den full $Obj) mit (dem $Tool) ab(no space)(zu)(no space)schneiden

(describe action [lock $Obj])
	(den full $Obj) ab(no space)(zu)(no space)schneiden

(understand infinitive [trennen/durchtrennen/durchschneiden/kürzen/abschneiden] as Verb [schneid])

(rewrite [trenn/durchtrenn/durchschneid/kürz | $Words] into [schneid | $Words])

(understand [schneid/trenn durch/ab | $Words] as [cut $A with $B])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $A)
	*(understand $Right as single object $B)

(understand [trenn/durchtrenn/durchschneid/kürz/schneid | $Words] as [cut $A with $B])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $A)
	*(understand $Right as single object $B)

(understand [trenn/durchtrenn/durchschneid/kürz/schneid | $Words] as [cut $Obj])
	*(understand $Words as non-all object $Obj)

(understand [trenn/schneid durch/ab | $Words] as [cut $Obj])
	*(understand $Words as non-all object $Obj)

(unlikely [cut $ with $Obj])
	~(sharp $Obj)

(perform [cut $Obj])
	Womit?
	(asking for object in [cut $Obj with []])

(prevent [cut $ with $Obj])
	~(sharp $Obj)
	(Der $Obj ist) dafür zu stumpf. %% Funny when Obj is the player.

(perform [cut $Obj with $])
	Du erwägst (den $Obj)
	(if) ($Obj is part of $Player) (current player $Player) (then)
		ab
	(else)
		auseinander
	(endif)
	zu schneiden, verwirfst die Idee aber wieder.

%% USE <obj>

(describe action [use $Obj])
	(den full $Obj) (zu) benutzen

(understand infinitive [benutzen] as Verb [benutz])

(understand [benutz | $Words] as $Action)
	*(understand $Words as single object $Obj)
	(if)
		(implicit action is $Implicit)
		~(implicit action wants direction)
	(then)
		(recover implicit action $Implicit $Obj into $Action)
	(else)
		($Action = [use $Obj])
	(endif)

(instead of [use (door $Door)])
	(try [enter $Door])

(perform [use $])
	Wie? Sei bitte etwas präziser.
	(stop)

%% CONSULT <obj> ABOUT <topic>

(describe action [consult $Obj about $Topic])
	in (dem $Obj) nach (describe topic $Topic) (zu) suchen

(understand infinitive [nachschlagen/nachschauen/konsultieren] as Verb [konsultier])

(understand [schlag/schau | $Words] as [consult $Obj about $Topic])
	*(split $Words by [nach] into $Left and $Right)
	{
		($Left = [])
		*(split $Right by [in] into $Was and $Ist)
	(or)
		($Right = [])
		*(split $Left by [in] into $Was and $Ist)
	(or)
		($Left = [in | $Rest])
		($Ist = $Rest)
		($Was = $Right)
	(or) 
		($Right = [in | $Rest])
		($Ist = $Rest)
		($Was = $Left)
	}
	*(understand $Was as topic $Topic)
	*(understand $Ist as single object $Obj)

(understand [find | $Words] as [consult $Obj about $Topic])
	*(split $Words by [in] into $Left and $Right)
	*(understand $Left as single object $Obj)
	*(understand $Right as topic $Topic)

(understand [konsultier | $Words] as [consult $Obj about $Topic])
	*(split $Words by [über] into $Left and $Right)
	*(understand $Left as single object $Obj)
	*(understand $Right as topic $Topic)

(describe action [consult $Obj about $Topic])
	in (dem full $Obj) (describe topic $Topic) nach(no space)(zu)(no space)schlagen

(unlikely [consult $Obj about $])
	~(consultable $Obj)

(refuse [consult $Obj about $])
	(just) {
		(when $Obj is not here)
		(or) (when $Obj is out of reach)
	}

(prevent [consult $Obj about $])
	~(consultable $Obj)
	In (dem $Obj) (lässt sich $Obj) nichts nachschlagen.

(perform [consult $Obj about $Topic])
	Du findest keine Information über (describe topic $Topic) in (dem $Obj).

%% ASK/TELL <obj> ABOUT <topic> (redirected to TALK TO by default)

(describe action [ask $Obj about $Topic])
	(describe person $Obj) nach (describe topic $Topic) (zu) fragen

(describe action [tell $Obj about $Topic])
	(describe dative person $Obj) von (describe topic $Topic) (zu) erzählen

(understand infinitive [fragen/befragen] as Verb [frag])
(understand infinitive [sagen] as Verb [sag])
(understand infinitive [erzählen] as Verb [erzähl])

(understand [frag/befrag | $Words] as [ask $Person about $Topic])
	*(split $Words by [nach über] into $Left and $Right)
	*(understand $Left as single object $Person preferably animate)
	*(understand $Right as topic $Topic)

(understand [erzähl | $Words] as [tell $Person about $Topic])
	*(split $Words by [über von] into $Left and $Right)
	*(understand $Left as single object $Person preferably animate)
	*(understand $Right as topic $Topic)

(understand [sag | $Words] as [tell $Person about $Topic])
	*(split $Words by [zu] into $Left and $Right)
	*(understand $Left as topic $Topic)
	*(understand $Right as single object $Person preferably animate)

(understand [red/sprech/sprich mit | $Words] as [tell $Person about $Topic])
	*(split $Words by [über] into $Left and $Right)
	*(understand $Left as single object $Person preferably animate)
	*(understand $Right as topic $Topic)

(describe action [ask $Person about $Topic])
	(describe person $Person) nach (describe topic $Topic) (zu) fragen

(describe action [tell $Person about $Topic])
	(describe person $Person) von (describe topic $Topic) (zu) erzählen

(understand [frag | $Words] as [ask $Obj])
	*(understand $Words as single object $Obj preferably animate)

(understand [erzähl | $Words] as [tell $Obj])
	*(understand $Words as single object $Obj preferably animate)

(describe action [ask $Person])
	(den full $Person) nach etwas (zu) fragen

(describe action [tell $Person])
	(der full $Person) etwas (zu) erzählen

(unlikely [ask/tell $Obj about $])
	~(animate $Obj)

%% Don't require reachability:

(refuse [ask $Obj | $])
	(just) (when $Obj is not here)

(refuse [tell $Obj about $])
	(just) (when $Obj is not here)

(refuse [tell $Obj])
	(just) (when $Obj is not here)

(perform [ask/tell $Person about $Topic])
	(try [talk to $Person about $Topic])

(perform [ask/tell $Obj])
	(try [talk to $Obj])

%% TALK TO <obj> ABOUT <topic>
%% TALK TO <obj>
%% TALK

(describe action [talk to $Obj])
	mit (describe dative person $Obj) (zu) reden

(describe action [talk])
	(zu) reden

(understand infinitive [reden] as Verb [red])
(understand infinitive [sprechen] as Verb [sprech])

(understand [red/sprich/sprech mit | $Words] as [talk to $Obj])
	*(understand $Words as single object $Obj preferably animate)

(understand [red] as [talk])

(describe action [talk to $Person about $Topic])
	mit (dem full $Person) über (describe topic $Topic) (zu) reden

(unlikely [talk to $Obj])
	~(animate $Obj)

(perform [talk])
	Mit wem?
	(asking for object in [talk to []])

%% Don't require reachability:

(refuse [talk to $Obj | $])
	(just) (when $Obj is not here)

(perform [talk to $Obj about $])
	(try [talk to $Obj])

(perform [talk to (current player $)])
	Du sprichst dir wenige ausgewählte Worte zu.

(perform [talk to $])
	Du bekommst keine Antwort.

%% CURSE

(understand infinitive [fluchen/schimpfen] as Verb [fluch])

(understand [fluch/schmipf/mist/kacke/shit/fuck/scheiße] as [curse])

(perform [curse])
	Du sprichst wenige ausgewählte Worte laut aus.

%% SHOUT TO <obj> (redirected to TALK TO by default)
%% SHOUT (redirected to TALK by default)

(describe action [shout to $Obj])
	(describe dative person $Obj) (zu) schreien

(describe action [shout])
	(zu) schreien

(understand [brüll/schrei an | $Words] as [shout to $Obj])
	*(understand $Words as single object $Obj preferably animate)
	
(unlikely [shout to $Obj])
	~(animate $Obj)

(refuse [shout to $Obj])
	(just) (when $Obj is not here)

(perform [shout to $Obj])
	(try [talk to $Obj])

(understand [schrei] as [shout])

(perform [shout])
	Wem?
	(asking for object in [shout to []])

%% PRAY

(describe action [pray])
	(zu) beten

(understand infinitive [beten] as Verb [bet])

(understand [bet] as [pray])
(understand [schick ein gebet] as [pray])

(perform [pray])
	Du schickst ein Gebet zum Himmel.

%% SHRUG

(describe action [shrug])
	die Schultern (zu) zucken

(understand [zuck mit der schulter/achsel] as [shrug])

(perform [shrug])
	Du zuckst ungewiss mit deiner Schulter.

%% CALL <obj> (redirected to SHOUT TO by default)
%% CALL (redirected to SHOUT by default)
%% Stories containing a phone would override these.

(describe action [call $Obj])
	(den full $Obj) (zu) rufen

(describe action [call])
	(zu) rufen

(understand infinitive [rufen] as Verb [ruf])

(understand [ruf an | $Words] as [call $Obj])
	*(understand $Words as single object $Obj preferably animate)

(understand [ruf | $Words] as [call $Obj])
	*(understand $Words as single object $Obj preferably animate)

(unlikely [call $Obj])
	~(animate $Obj)

(refuse [call $Obj])
	(just) (when $Obj is not here)

(perform [call $Obj])
	(try [shout to $Obj])

(understand [ruf an] as [call])

(perform [call])
	Wen?
	(asking for object in [call []])

%% GREET <obj> (redirected to TALK TO by default)
%% GREET

(describe action [greet $Obj])
	(den full $Obj) (zu) grüßen

(describe action [greet])
	(zu) grüßen

(understand infinitive [begrüßen/grüßen] as Verb [begrüß])

(understand [begrüß/grüß/hallo/hi | $Words] as [greet $Obj])
	*(understand $Words as single object $Obj preferably animate)

(understand [sag hallo/hi zu | $Words] as [greet $Obj])
	*(understand $Words as single object $Obj preferably animate)

(unlikely [greet $Obj])
	~(animate $Obj)

(refuse [greet $Obj])
	(just) (when $Obj is not here)

(perform [greet $Obj])
	(try [talk to $Obj])

(understand [greet])

(perform [greet])
	Du wirfst ein Hallo in die Runde.

%% TELL <obj> TO | <action>

(understand infinitive [sagen] as Verb [sag])
(understand infinitive [bitten] as Verb [bitt])

(understand [sag/bitt | $Words] as [tell $Actor to | $Action])
	*(split $Words by [, er sie es] into $Left and $Right)
	*(understand $Left as single object $Actor preferably animate)
	*(split $Right by [soll möchte sollte könnte kann] into $ and $Order)
	(current actor $OldActor)
	(now) (current actor $Actor)
	(rewrite $Order into $Simplified)
	(collect $A)
		*(understand $Simplified as $A)
	(into $List)
	(now) (current actor $OldActor)
	$List
	*($Action is one of $List)

(understand [bitt | $Words] as [tell $Actor to give $Obj to $Player])
	*(split $Words by [um] into $Left and $Right)
	*(understand $Left as single object $Actor preferably animate)
	*(understand $Right as object $Obj preferably child of $Actor)
	(current player $Player)

%% The rule for "name comma action" is further down in the file.

(unlikely [tell $Addressee to | $])
	~(animate $Addressee)

(describe action [tell $Actor to give $Obj to (current player $)])
	(describe person $Actor) um (den full $Obj) (zu) bitten

(describe action [tell $Actor to tell (current player $) about $Topic])
	(dem full $Actor) über (describe topic $Topic) (zu) erzählen

(describe action [tell $Actor to | $Action])
	(dem full $Actor) (zu) sagen, (er $Actor) (soll $Actor) 
	(now) ~(infinitive context) 
	(describe action $Action)

(unlikely [tell $Obj to | $])
	~(animate $Obj)

(refuse [tell $NPC to | $])
	(just) (when $NPC is not here)

(instead of [tell $NPC to greet])
	(try [greet $NPC])

(instead of [tell $NPC to tell (current player $) about $Topic])
	(try [ask $NPC about $Topic])

(perform [tell $Actor to | $])
	(if) (animate $Actor) (then)
		(Der $Actor) weigert sich.
	(else)
		(Der $Actor) (nimmt $Actor) keine Befehle entgegen.
	(endif)

%% SMELL <obj>

(describe action [smell $Obj])
	an (dem $Obj) (zu) riechen

(understand infinitive [schnüffeln] as Verb [schnüffel])
(understand infinitive [riechen] as Verb [riech])

(rewrite [schnüffel/riech an | $Words] into [riech | $Words])

(understand [riech/schnüffel | $Words] as [smell $Obj])
	*(understand $Words as non-all object $Obj)

(refuse [smell $Obj])
	(just) (when $Obj is not here)

(perform [smell $Obj])
	(Der $Obj) riecht wie erwartet.

(understand [smell])

(perform [smell])
	Du atmest ein und riechst nichts Ungewöhnliches.

%% WAKE UP

(describe action [wake up])
	auf(no space)(zu)(no space)wachen

(understand infinitive [erwachen/aufwachen/zwicken] as Verb [wach auf])

(understand [wach auf] as [wake up])

(understand [zwick/weck | $Words] as [wake up])
	*(understand $Words as single object $Obj)
	(current player $Player)
	{
		($Obj = $Player)
	(or)
		($Obj is part of $Player)
	}

(perform [wake up])
	Du versuchst aufzuwachen, aber es hat sich nichts verändert.

%% CLIMB <obj>

(understand infinitive [klettern] as Verb [kletter])
(understand infinitive [erklimmen/ersteigen/erklettern] as Verb [erkletter])

(understand [kletter hoch an | $Words] as [climb $Obj])
	*(understand $Words as single object $Obj preferably supporter)

(understand [kletter/geh/steig auf | $Words] as [climb $Obj])
	*(understand $Words as single object $Obj preferably supporter)

(understand [erkletter/erklimm/ersteig | $Words] as [climb $Obj])
	*(understand $Words as single object $Obj preferably supporter)

(unlikely [climb $Obj])
	~(actor supporter $Obj)

(unlikely [climb $Obj])
	(current player $Actor)
	($Obj has ancestor $Actor)

(unlikely [climb $Obj])
	(current player $Actor)
	($Actor is nested #on $Obj)

(describe action [climb $Obj])
	auf (den full $Obj) (zu) klettern

(instead of [climb (room $Room)])
	~(actor supporter $Room)
	(try [go #up])

(instead of [climb (actor container $Obj)])
	~(actor supporter $Obj)
	(seat $Obj)
	(try [enter $Obj])

(prevent [climb $Obj])
	(current player $Actor)
	{
		(when $Actor is already #on $Obj)
		(or) (when $Obj won't accept actor #on)
	}

(prevent [climb $Dest])
	(current player $Actor)
	($Dest is nested #in $Actor)
	Das geht schlecht, solange du (den $Dest) bei dir hast.

(narrate climbing $Obj)
	Du bist nun auf (dem $Obj).

(perform [climb $Obj])
	(narrate climbing $Obj)
	(current player $Actor)
	(now) ($Actor is #on $Obj)

%% ENTER <obj>

(understand infinitive [betreten] as Verb [betritt])
(understand infinitive [steigen] as Verb [steig])
(understand infinitive [klettern] as Verb [kletter])
(understand infinitive [setzen] as Verb [setz])
(understand infinitive [stellen] as Verb [stell])
(understand infinitive [liegen] as Verb [lieg])
(understand infinitive [gelangen] as Verb [gelang])

(understand [betritt/betret | $Words] as [enter $Obj])
	*(understand $Words as single object $Obj preferably container)

(understand [geh/spring/gelang/sitz/kletter/lieg/sitz/steig in/durch | $Words] as [enter $Obj])
	*(understand $Words as single object $Obj preferably container)

(unlikely [enter $Obj])
	~(actor container $Obj)
	~(door $Obj)

(unlikely [enter $Obj])
	(current player $Actor)
	($Obj has ancestor $Actor)

(unlikely [enter $Obj])
	(current player $Actor)
	($Actor is nested #in $Obj)

~(very unlikely [enter $])

(describe action [enter $Obj])
	in (den full $Obj) (zu) steigen

~(refuse [enter (room $)])

(instead of [enter (actor supporter $Obj)])
	(try [climb $Obj])

(instead of [enter (room $Room)])
	(current room $Here)
	~($Here = $Room)
	(if)
		(from $Here go $Dir to $Room)
	(or)
		(from $Here through $Door to $Room)
		(from $Here go $Dir to $Door)
	(then)
		(direction $Dir) %% Assure the compiler that $Dir is bound.
		(try [go $Dir])
	(else)
		(Der $Room ist) nicht hier.
		(tick) (stop)
	(endif)

(instead of [enter (door $Obj)])
	(current room $Room)
	(from $Room go $Dir to $Obj)
	(direction $Dir) %% Assure the compiler that $Dir is bound.
	(try [go $Dir])

(instead of [enter (wearable $Obj)])
	(try [wear $Obj])

(instead of [enter (actor supporter $Obj)])
	~(actor container $Obj)
	(seat $Obj)
	(try [climb $Obj])

(prevent [enter $Obj])
	(current player $Actor)
	{
		(when $Actor is already #in $Obj)
		(or) (prevent entering $Obj)
	}

(prevent [enter $Dest])
	(current player $Actor)
	($Dest is nested #in $Actor)
	Das geht schlecht, solange du (den $Dest) bei dir hast.

(perform [enter $Obj])
	(narrate entering $Obj)
	(current player $Actor)
	(now) ($Actor is #in $Obj)

%% SIT

(describe action [sit])
	hin(no space)(zu)(no space)setzen

(understand [setz dich] as [sit])
(understand [sitz] as [sit])

(unlikely [sit])

(perform [sit])
	Worauf?
	(asking for object in [climb []])

%% STAND

(rewrite [steh auf] into [steh])

(understand [steh] as [stand])

(describe action [stand])
	auf(no space)(zu)(no space)stehen

(instead of [stand])
	(current player $Player)
	($Player has parent $Obj)
	~(room $Obj)
	(try [leave $Obj])

(perform [stand])
	Du stehst schon.
	(tick) (stop)

%% LEAVE <obj>
%% LEAVE

(describe action [leave])
	weg(no space)(zu)(no space)gehen

(describe action [leave $Obj])
	(den full $Obj) (zu) verlassen

(understand infinitive [verlassen] as Verb [verlass])
(understand infinitive [fliehen] as Verb [flieh])

(understand [verlass | $Words] as [leave $Obj])
	*(understand $Words as single object $Obj)

(understand [geh/flieh/spring aus | $Words] as [leave $Obj])
	*(understand $Words as single object $Obj preferably container)

(understand [geh/flieh/spring von | $Words] as [leave $Obj])
	*(understand $Words as single object $Obj preferably supporter)

(understand [geh raus/hinaus] as [leave])

(understand [geh runter] as [leave])
	(current player $Player)
	($Player has relation #on)

(understand [spring runter] as [leave])
	(current player $Player)
	($Player has relation #on)

(describe action [leave $Obj])
	(current player $Player)
	($Player is $Rel $Obj)
	(reverse-name $Rel) (den full $Obj) (zu) verlassen

(describe action [leave])
	(current player $Player)
	($Player is $Rel $Obj)
	~(room $Obj)
	(reverse-name $Rel) (den full $Obj) (zu) verlassen

(unlikely [leave $Obj])
	(current player $Actor)
	~{
		($Actor has ancestor $Obj)
	(or)
		($Obj is nested #wornby $Actor)
	}

~(very unlikely [leave (current room $)])

(refuse [leave (room $Room)])
	~(current room $Room)
	Aber du bist gar nicht in (dem $Room).

(perform [leave])
	(current player $Player)
	($Player has parent $Obj)
	(if) (room $Obj) (then)
		(try [go #out])
	(else)
		(try [leave $Obj])
	(endif)

(before [leave $Obj])
	(current player $Actor)
	($Actor has ancestor $Obj)
	(recursively leave descendants of $Obj)

(instead of [leave $Obj])
	(current player $Actor)
	($Obj is nested #wornby $Actor)
	(try [remove $Obj])

(instead of [leave (current room $)])
	(try [go #out])

(prevent [leave $Obj])
	(current player $Player)
	~($Player has parent $Obj)
	Du bist nicht
	(if) (supporter $Obj) (then)
		(if) (container $Obj) (then)
			in
		(endif)
		auf
	(else)
		in
	(endif)
	(dem $Obj).

(narrate leaving $Obj)
	Du verlässt (den $Obj).

(perform [leave $Obj])
	(narrate leaving $Obj)
	(current player $Player)
	($Obj is $NewRel $NewObj)
	(now) ($Player is $NewRel $NewObj)

%% GO TO <room>

%% It is only possible to go to visited rooms and non-hidden objects in this
%% way.

(describe action [go to $Room])
	(den $Room) auf(no space)(zu)(no space)suchen

(understand infinitive [nähern] as Verb [näher])

(understand [geh in/zu | $Words] as [go to $Room])
	(filter $Words into $Filtered)
	(nonempty $Filtered)
	(determine object $Room)
		*(room $Room)
		($Room is visited)
	(from words)
		*(dict $Room)
	(matching all of $Filtered)

(understand [näher dich | $Words] as [go to $Room])
	(filter $Words into $Filtered)
	(nonempty $Filtered)
	(determine object $Room)
		*(room $Room)
		($Room is visited)
	(from words)
		*(dict $Room)
	(matching all of $Filtered)

(understand [such auf | $Words] as [go to $Room])
	(filter $Words into $Filtered)
	(nonempty $Filtered)
	(determine object $Room)
		*(room $Room)
		($Room is visited)
	(from words)
		*(dict $Room)
	(matching all of $Filtered)
	
(unlikely [go to (current room $)])

~(very unlikely [go to $])

~(refuse [go to $])

(perform [go to $Room])
	(current room $Here)
	(if) ($Here = $Room) (then)
		Du bist schon in (dem $Room).
		(tick) (stop)
	(elseif) (shortest path from $Here to $Room is $Path) (then)
		(exhaust) {
			*($Dir is one of $Path)
			(line) \( nach (name $Dir) gehen \) (line)
			(try [go $Dir])
			(tick)
			(par)
		}
		(inhibit next tick)
	(else)
		Du weißt nicht, wie du von hier zu (dem $Room) gelangst.
		(tick) (stop)
	(endif)

%% Navigation by direction:

%% What the player types is eventually translated into one of:

%% [leave $Room $Dir]
%% [leave $Room $Dir by $Vehicle]
%% [leave $Room $Dir with $Obj]

%% These are generally the ones to override/extend.

%% The default rules for the aforementioned actions invoke '(prevent entering
%% $Room)' and '(narrate entering $Room)'. These predicates can of course also
%% be overridden. Thus, entering a room is not an action of its own, but is
%% an inherent part of leaving a room.

%% GO <direction>

(describe action [go $Dir])
	nach (den $Dir) (zu) gehen

%% The rule for just typing a list of directions (without a verb) is further
%% down in the file.

(understand infinitive [gehen] as Verb [geh])
(understand infinitive [gelangen] as Verb [gelang])
(understand infinitive [kriechen] as Verb [kriech])

(understand [geh/kriech weiter nach | $Words] as [go $Dir])
	*(understand $Words as direction $Dir)

(understand [geh/kriech nach | $Words] as [go $Dir])
	*(understand $Words as direction $Dir)

(understand [geh/kriech | $Words] as [go $Dir])
	*(understand $Words as direction $Dir)

(understand [gelang nach | $Words] as [go $Dir])
	*(understand $Words as direction $Dir)

(understand [kletter nach | $Words] as [go $Dir])
	*(understand $Words as direction $Dir)
	*($Dir is one of [#up #down])

(understand [beweg dich nach | $Words] as [go $Dir])
	*(understand $Words as direction $Dir)

(understand [geh] as [go #out])

(understand [raus] as [go #out])
(understand [hinaus] as [go #out])
(understand [rein] as [go #in])
(understand [hinein] as [go #in])

(understand [kletter hoch] as [go #up])
(understand [geh hoch] as [go #up])
(understand [hoch] as [go #up])

(understand [kletter runter] as [go #down])
(understand [geh runter] as [go #down])
(understand [runter] as [go #down])

(unlikely-complex [go $DirList] 0)
	(just)
	(if) (direction $DirList) (then)
		($Dir = $DirList)
	(else)
		%% Only consider the first direction in the list.
		([+ $Dir | $] = $DirList)
	(endif)
	(current room $Room)
	~{
		(from $Room go $Dir to $Target)
		{ (room $Target) (or) (door $Target) (or) (direction $Target) }
	}

(before [go $Dir])
	(current player $Actor)
	~{ ($Dir = #down) ($Actor has relation #on) }
	~{ ($Dir = #out) ($Actor has relation #in) }
	~{ ($Dir = #up) ($Actor has parent $Parent) (seat $Parent) }
	(recursively leave non-vehicles)

(before [go $Dir])
	(current player $Actor)
	~{ ($Dir = #down) ($Actor has relation #on) }
	~{ ($Dir = #out) ($Actor has relation #in) }
	(current room $Room)
	(from $Room go $Dir to $Target)
	(door $Target)
	($Target is closed)
	(first try [open $Target])

(instead of [go #up])
	(current player $Player)
	($Player has parent $Obj)
	(seat $Obj)
	(try [leave $Obj])

(instead of [go #down])
	(current player $Actor)
	($Actor is #on $Obj)
	(try [leave $Obj])

(instead of [go #out])
	(current player $Actor)
	($Actor is #in $Obj)
	~(room $Obj)
	(try [leave $Obj])

(prevent [go $])
	(current player $Actor)
	($Actor is $Rel $Obj)
	~(room $Obj)
	~(vehicle $Obj)
	(when $Actor is $Rel $Obj)

(perform [go $Dir])
	(current player $Actor)
	(current room $Room)
	(if) ($Actor has parent $Room) (then)
		(try [leave $Room $Dir])
	(else)
		($Actor has parent $Vehicle)
		(try [leave $Room $Dir by $Vehicle])
	(endif)

%% PUSH <obj> <dir>

(describe action [push $Obj $Dest])
	(den full $Obj) nach (name $Dest) (zu) schieben

(understand infinitive [schieben] as Verb [schieb])
(understand infinitive [verschieben] as Verb [verschieb])
(understand infinitive [drücken] as Verb [drück])
(understand infinitive [hieven] as Verb [hiev])

(understand [schieb/verschieb/beweg/drück/hiev/zieh | $Words] as [push $Obj $Dir])
	*(split $Words by [nach] into $Left and $Right)
	*(understand $Right as direction $Dir)
	*(understand $Left as single object $Obj)

(understand [schieb/verschieb/beweg/drück/hiev/zieh | $Words] as [push $Obj $Dir])
	*(split $Words anywhere into $Left and $Right)
	*(understand $Right as direction $Dir)
	*(understand $Left as single object $Obj)

(unlikely [push $Obj $])
	~(pushable $Obj)

(before [push $ $])
	(recursively leave non-vehicles)

(before [push $ $Dir])
	(current room $Room)
	(from $Room go $Dir to $Target)
	(door $Target)
	($Target is closed)
	(first try [open $Target])

(prevent [push $Obj $])
	~(pushable $Obj)
	(Der $Obj) (lässt sich $Obj) nicht schieben.

(prevent [push $ $])
	(current player $Actor)
	($Actor is $Rel $Obj)
	~{ ($Rel = #in) (room $Obj) }
	(when $Actor is $Rel $Obj)

(perform [push $Obj $Dir])
	(current room $Room)
	(try [leave $Room $Dir with $Obj])

%% PUSH <obj>

(describe action [push $Obj])
	(den full $Obj) (zu) schieben

(understand [schieb/verschieb/beweg/drück/hiev | $Words] as [push $Obj])
	*(understand $Words as non-all object $Obj)

(understand [schieb an | $Words] as [push $Obj])
	*(understand $Words as non-all object $Obj)

(perform [push (pushable $Obj)])
	In welche Richtung?
	(asking for direction in [push $Obj []])

(perform [push (room $)])
	Deine Umgebung herum zu schieben, hat keinen nennenswerten Effekt.

(perform [push (item $Obj)])
	Du gibst (dem $Obj) einen kleinen Schubs.

(perform [push $Obj])
	Du versuchst, (den $Obj) zu schieben, aber (er $Obj) bewegt sich nicht.

%% PULL <obj>

(describe action [pull $Obj])
	(den full $Obj) (zu) ziehen

(understand infinitive [zerren] as Verb [zerr])

(rewrite [zerr/zieh an | $Words] into [zieh | $Words])

(understand [zieh | $Words] as [pull $Obj])
	*(understand $Words as non-all object $Obj)

(perform [pull $Obj])
	Du ziehst an (dem $Obj), aber
	(if) (item $Obj) (then)
		ohne nennenswerte Auswirkung.
	(else)
		(der $Obj) (lässt sich $Obj) nicht bewegen.
	(endif)

%% TURN <obj>

(describe action [turn $Obj])
	(den full $Obj) (zu) drehen

(understand infinitive [wenden] as Verb [wend])

(understand [dreh/wend um | $Words] as [turn $Obj])
	*(understand $Words as non-all object $Obj)

(understand [dreh/wend | $Words] as [turn $Obj])
	*(understand $Words as non-all object $Obj)

(prevent [turn (room $Obj)])
	Du kannst (den $Obj) nicht drehen.

(perform [turn $Obj])
	(Den $Obj) zu drehen zeigt keine Wirkung.

%% READ <obj>

(describe action [read $Obj])
	(den full $Obj) (zu) lesen

(understand infinitive [lesen] as Verb [les])

(understand [lies/lies | $Words] as [read $Obj])
	*(understand $Words as non-all object $Obj)

(prevent [read $])
	~(player can see)
	Es ist zu dunkel zum lesen.

(perform [read $Obj])
	Da ist keine Schrift auf (dem $Obj).

%% FLUSH <obj>
%% FLUSH

(describe action [flush $Obj])
	(den full $Obj) (zu) spülen

(understand infinitive [spülen] as Verb [spül])

(understand [spül | $Words] as [flush $Obj])
	*(understand $Words as non-all object $Obj)

(perform [flush $Obj])
	(Der $Obj) (lässt sich $Obj) nicht spülen.
	(tick) (stop)

(prevent [flush $Obj])
	(current player $Obj)
	Wirklich?

(understand [spül] as [flush])

(perform [flush])
	Was willst du spülen?
	(asking for object in [flush []])

%% SWIM IN <obj>
%% SWIM

(describe action [swim $Obj])
	in (dem full $Obj) (zu) schwimmen

(understand infinitive [schwimmen] as Verb [schwimm])
(understand infinitive [baden] as Verb [bad])

(understand [schwimm/bad] as [swim])

(understand [schwimm/bad in | $Words] as [swim in $Obj])
	*(understand $Words as single object $Obj)

(perform [swim in $Obj])
	Du kannst nicht in (dem $Obj) schwimmen.
	(tick) (stop)

(understand [swim])

(perform [swim])
	Worin?
	(asking for object in [swim in []])

%% CLEAN <obj>

(describe action [clean $Obj])
	(den full $Obj) (zu) reinigen

(understand infinitive [waschen] as Verb [wasch])
(understand infinitive [reinigen] as Verb [reinig])
(understand infinitive [bürsten] as Verb [bürst])
(understand infinitive [wischen] as Verb [wisch])
(understand infinitive [polieren] as Verb [polier])
(understand infinitive [fegen] as Verb [feg])
(understand infinitive [entstauben] as Verb [entstaub])
(understand infinitive [schrubben] as Verb [schrubb])

(understand [wasch/reinig/bürst/wisch/polier/feg/entstaub/schrubb | $Words] as [clean $Obj])
	*(understand $Words as non-all object $Obj)

(perform [clean $Obj])
	Du startest einen halbherzigen Versuch, (den $Obj) zu reinigen.

%% TIE <obj> TO <obj>
%% TIE <obj>

(describe action [tie $Obj to $Dest])
	(den full $Obj) an (den $Dest) (zu) binden

(understand infinitive [binden] as Verb [bind])
(understand infinitive [verbinden] as Verb [verbind])
(understand infinitive [befestigen] as Verb [befestig])
(understand infinitive [machen] as Verb [mach])

(rewrite [verbind | $Words] into [bind | $Words])
(rewrite [befestig | $Words] into [bind | $Words])

(understand [bind/mach fest | $Words] as [tie $A to $B])
	*(split $Words by [an um auf] into $Left and $Right)
	*(understand $Left as single object $A)
	*(understand $Right as single object $B)

(understand [bind | $Words] as [tie $A to $B])
	*(split $Words by [an um auf] into $Left and $Right)
	*(understand $Left as single object $A)
	*(understand $Right as single object $B)

(understand [bind | $Words] as [tie $Obj])
	*(understand $Words as single object $Obj)

(unlikely [tie $])

(perform [tie $Obj])
	Woran?
	(asking for object in [tie $Obj to []])

(perform [tie $A to $B])
	Du siehst keine Möglichkeit, (den $A) an (den $B) zu binden.
	(tick) (stop)

%% UNTIE <obj> FROM <obj>
%% UNTIE <obj>

(describe action [untie $Obj from $Dest])
	(den full $Obj) von (dem $Dest) (zu) lösen

(understand infinitive [lockern] as Verb [locker])
(understand infinitive [lösen] as Verb [lös])

(understand [mach locker/ab/los | $Words] as [untie $A from $B])
	*(split $Words by [von] into $Left and $Right)
	*(understand $Left as single object $A)
	*(understand $Right as single object $B)

(understand [lös | $Words] as [untie $A from $B])
	*(split $Words by [von] into $Left and $Right)
	*(understand $Left as single object $A)
	*(understand $Right as single object $B)

(unlikely [untie $Obj from $])
	(unlikely [untie $Obj])

(understand [lös/locker | $Words] as [untie $Obj])
	*(understand $Words as non-all object $Obj)

(understand [mach locker/ab/los | $Words] as [untie $Obj])
	*(understand $Words as non-all object $Obj)

(perform [untie $Obj])
	(Der $Obj) (lässt sich $Obj) nicht lösen.
	(tick) (stop)

(perform [untie $Obj from $OtherObj])
	(Der $Obj ist) nicht an (dem $OtherObj) befestigt.
	(tick) (stop)

%% ATTACK <obj> WITH <obj>
%% ATTACK <obj>

(describe action [attack $Obj])
	(den full $Obj) an(no space)(zu)(no space)greifen

(describe action [attack $Obj with $Weapon])
	(den full $Obj) mit (dem $Weapon) an(no space)(zu)(no space)greifen

(understand infinitive [brechen] as Verb [brech])
(understand infinitive [zerbrechen] as Verb [zerbrech])
(understand infinitive [zerschlagen] as Verb [zerschlag])
(understand infinitive [hauen] as Verb [hau])
(understand infinitive [treten] as Verb [tret])
(understand infinitive [quälen] as Verb [quäl])
(understand infinitive [zerstören] as Verb [zerstör])
(understand infinitive [töten] as Verb [töt])
(understand infinitive [ermorden] as Verb [ermord])
(understand infinitive [kämpfen] as Verb [kämpf])

(understand [schlag/brech/zerbrech/brich/zerbrich/zerschlag/hau/tret/quäl/zerstör/töt/ermord | $Words] as [attack $Obj])
	*(understand $Words as non-all object $Obj)

(understand [brich | $Words] as [attack $A with $B])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $A)
	*(understand $Right as object $B preferably held)

(understand [schlag | $Words] as [attack $A with $B])
	*(split $Words by [mit] into $Left and $Right)
	*(understand $Left as non-all object $A)
	*(understand $Right as object $B preferably held)

(unlikely [attack $ with $Obj])
	~(item $Obj)

(unlikely [attack $ with $Obj])
	(current player $Actor)
	~($Obj has ancestor $Actor)

(before [attack $ with $Obj])
	(ensure $Obj is held)

(prevent [attack $ with $Obj])
	(when $Obj isn't directly held)

(perform [attack $Obj with $])
	(try [attack $Obj])

(understand [attack | $Words] as [attack $Obj])
	*(understand $Words as single object $Obj)

(perform [attack $])
	Du verwirfst die Idee wieder.

%% LEAVE <room> <dir>
%% LEAVE <room> <dir> BY <vehicle>
%% LEAVE <room> <dir> WITH <object>

(describe action [leave $Room $Dest])
	(den $Room) nach (name $Dest) (zu) verlassen

(describe action [leave $Room $Dest with $Obj])
	(den $Room) nach (name $Dest) mit (dem $Obj)(zu) verlassen

(describe action [leave $Room $Dest by $Obj])
	(den $Room) nach (name $Dest) mit (dem $Obj) (zu) verlassen

(instead of [leave $Room $Dir])
	(from $Room go $Dir to $Target)
	(direction $Target)
	(try [leave $Room $Target])

(prevent [leave $Room $Dir])
	(if) (from $Room go $Dir to $Target) (then)
		(if) (door $Target) (then)
			{
				(when $Target blocks passage)
			(or)
				(from $Room through $Target to $OtherRoom)
				(prevent entering $OtherRoom)
			}
		(elseif) (room $Target) (then)
			(prevent entering $Target)
		(else)
			(narrate failing to leave $Room $Dir)
		(endif)
	(else)
		(if) ($Dir is one of [#out #in]) (then)
			In welche Richtung?
			(asking for direction in [go []])
		(else)
			(narrate failing to leave $Room $Dir)
		(endif)
	(endif)

(narrate leaving $Room $Dir)
	Du
	(if) ($Dir is one of [#up #down]) (then)
		kletterst
	(elseif) (player can see) (then)
		gehst nach
	(else)
		fühlst den Weg nach
	(endif)
	(if) ($Dir = #in) (then)
		drinnen
	(elseif) ($Dir = #out) (then)
		draußen
	(else)
		(name $Dir)
	(endif)
	(if) (from $Room go $Dir to $Target) (door $Target) (then)
		durch (den $Target)
	(endif)
	.

(perform [leave $Room $Dir])
	(narrate leaving $Room $Dir)
	(from $Room go $Dir to room $Target)
	(enter $Target)

(instead of [leave $Room $Dir with $Obj])
	(from $Room go $Dir to $Target)
	(direction $Target)
	(try [leave $Room $Target with $Obj])

(prevent [leave $Room $Dir with $])
	(prevent [leave $Room $Dir])

(narrate leaving $ $Dir with $Obj)
	Du schiebst (den $Obj) nach (name $Dir).
	(par)

(perform [leave $Room $Dir with $PushObj])
	(narrate leaving $Room $Dir with $PushObj)
	(from $Room go $Dir to room $NewRoom)
	(now) ($PushObj is #in $NewRoom)
	(now) ($PushObj is handled)
	(enter $NewRoom)

(instead of [leave $Room $Dir by $Obj])
	(from $Room go $Dir to $Target)
	(direction $Target)
	(try [leave $Room $Target by $Obj])

(prevent [leave $Room $Dir by $])
	(prevent [leave $Room $Dir])

(narrate leaving $ $Dir by $Obj)
	Du gelangst mit (dem $Obj) nach (name $Dir).
	(par)

(perform [leave $Room $Dir by $Vehicle])
	(narrate leaving $Room $Dir by $Vehicle)
	(from $Room go $Dir to room $NewRoom)
	(enter $NewRoom by $Vehicle)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 20: Commands

(interface (command $<Action))

@(understand command $Action)
	(understand $Action)
	(command $Action)

(describe action (command $Action))
	issue the (exhaust) { *($Word is one of $Action) $Word } command

%% AGAIN and UNDO are treated as a special cases in the toplevel parser.

%% QUIT

(command [quit])
(understand [quit/q/ende] as [quit])

(perform [quit])
	Willst du wirklich aufhören? \(j (no space) / (no space) n\)
	(if) (yesno) (then)
		(display quit message)
		(line)
		(quit)
	(endif)
	(stop)

(display quit message)
	(par)
	Danke für's Spielen!

%% RESTART

(command [restart])
(understand [neustart/start] as [restart])
(perform [restart])
	Willst du wirklich von vorn beginnen? \(j (no space) / (no space) n\)
	(if) (yesno) (then)
		(restart)
		Neustart fehlgeschlagen.
	(endif)
	(stop)

%% SAVE

(command [save])
(understand [speicher/save] as [save])
(perform [save])
	(if) (save $ComingBack) (then)
		(if) ($ComingBack = 1) (then)
			(roman)
			Spielstand erfolgreich geladen.
			(line)
			(location headline)
		(else)
			Spielstand erfolgreich gespeichert.
		(endif)
	(else)
		Das Speichern ist fehlgeschlagen.
	(endif)
	(stop)

%% RESTORE

(command [restore])
(understand [lad/load/restore] as [restore])
(perform [restore])
	(restore)
	Das Laden ist fehlgeschlagen.
	(stop)

%% TRANSCRIPT

(command [transcript on])
(understand [transcript/script on] as [transcript on])
(understand [transcript/script] as [transcript on])

(perform [transcript on])
	(if) (transcript on) (then)
		Spielmitschrift aktiviert.
	(else)
		Das Einschalten der Spielmitschrift ist fehlgeschlagen.
		(stop)
	(endif)

(command [transcript off])
(understand [transcript/script off] as [transcript off])

(perform [transcript off])
	(transcript off)
	Spielmitschrift deaktiviert.

%% SCORE

(understand command [score])
	(scoring enabled)

(perform [score])
	(scoring enabled)
	(current score $Score)
	Du hast momentan $Score
	(if) ($Score = 1) (then) Punkt (else) Punkte (endif)
	(if) (maximum score $Max) (then)
		von maximal $Max 
	(endif)
	erreicht.

%% NOTIFY

(understand command [notify on])
	(scoring enabled)

(perform [notify on])
	(scoring enabled)
	(now) (score notifications are on)
	Punktemitteilung aktiviert.

(understand command [notify off])
	(scoring enabled)

(perform [notify off])
	(scoring enabled)
	(now) ~(score notifications are on)
	Punktemitteilung deaktiviert.

%% PRONOUNS

(understand command [pronouns])
(perform [pronouns])
	"Mich" bezieht sich auf dich. (line)

	(collect $Obj)
		(player's es refers to $Obj)
	(or)
		(narrator's es refers to $Obj)
	(into $EsList)
	(if) (nonempty $EsList) (then) "Es" bezieht sich auf (den-oder-listing $EsList). (line) (endif)

	(collect $Obj)
		(player's ihn refers to $Obj)
	(or)
		(narrator's ihn refers to $Obj)
	(into $IhnList)
	(if) (nonempty $IhnList) (then) "Ihn" bezieht sich auf (den-oder-listing $IhnList). (line) (endif)

	(collect $Obj)
		(player's sie refers to $Obj)
	(or)
		(narrator's sie refers to $Obj)
	(into $SieList)
	(if) (nonempty $SieList) (then) "Sie" bezieht sich auf (den-oder-listing $SieList). (line) (endif)

	(if) (player's ihnen refers to $Ihnen) (then) "Ihnen" in Bezug auf den Spieler bezieht sich auf (den $Ihnen). (line) (endif)
	(if) (narrator's ihnen refers to $Ihnen) (then) "Ihnen" im Bezug auf den Erzähler bezieht sich auf (den $Ihnen). (line) (endif)

%% VERBOSE / BRIEF / SUPERBRIEF

(understand command [verbose])
(understand [brief/superbrief] as [verbose])

(perform [verbose])
	Die Wortfülle ist in dieser Geschichte nicht einstellbar.
	(stop)

%% VERSION

(understand command [version])
(understand [banner] as [version])
(perform [version])
	(banner)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 21: Understanding actions with special syntax

%% Rules for understanding actions that do not begin with a verb should go
%% here. This allows the other rules (that do begin with a verb) to be lumped
%% together into a single, efficient lookup operation.

(understand $Words as [go $Dir])
	~(implicit action wants direction)
	*(understand $Words as direction $Dir)

(understand $Words as [tell $Actor to | $Action])
	*(split $Words by [,] into $Left and $Right)
	*(understand $Left as single object $Actor preferably animate)
	(object $Actor) %% Significant when allowing parse errors.
		(current actor $OldActor)
	(now) (current actor $Actor)
	(rewrite $Right into $Simplified)
		(collect $A)
		*(understand $Simplified as $A)
	(into $List)
	(now) (current actor $OldActor)
	*($Action is one of $List)

(understand $Words as $Action)
	(default actions enabled)
	*(understand $Words as non-all object $Obj)
	~(empty $Obj)
	~($Obj = [1])
	(if) ($Obj = [a $RealObj]) (then)
		(default action $RealObj $Action)
	(else)
		(default action $Obj $Action)
	(endif)

(understand $Words as $Action)
	(implicit action is $Implicit)
	(if) (implicit action wants direction) (then)
		*(understand $Words as direction $O)
	(else)
		%% We don't know the correct policy, so fall back on 'non-all'.
		*(understand $Words as non-all object $O)
	(endif)
	(recover implicit action $Implicit $O into $Action)

(default action $Obj [examine $Obj])

(understand $Words as $Words)
	(understand $Words)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 22: Dealing with actions

%% If the player enters multiple actions on one line ("get lamp. n"), they
%% are parsed and carried out one at a time.

%% A complex action ("get all") is broken down, and the simple actions are
%% carried out in turn.

%% A (simple) action may invoke preliminary actions (e.g. open the door
%% before walking through it). These are carried out in turn.

%% After the preliminary actions (before) have been carried out, the action
%% is potentially refused. Normally, actions that involve unreachable objects
%% are refused; this is overridden by actions, such as look at, that don't
%% require reachability.

%% If the action wasn't refused, it will be handled by the (instead of $)
%% predicate. This predicate can be overridden for special cases in the story.
%% The default behaviour is to further break down handling into two stages:
%% Prevent and perform.
%% They are separate because it's convenient to be able to override
%% e.g. what happens when you put the twig in the fire without also overriding
%% the default checks, such as whether you are holding the twig.

%% (prevent $) should print something and succeed if the player character
%% tries, but there's a problem with completing the action. When prevent
%% succeeds, time is advanced (tick), and further actions are stopped.

%% If prevent fails, (perform $) is invoked to carry out the action. For the
%% eighteen core actions in this standard library, the perform rules call out
%% to a separate (narrate ...) rule, for stories that wish to override the
%% narration without affecting the default operations on the object tree.

%% Note that the world model is updated after narrating. This allows the
%% narrate rule to query the world as it used to be, before carrying out the
%% operation, in order to say for instance 'you take the worm out of the can'.

%% If something dramatic happens, an overriding rule should advance time if
%% necessary and (stop). So if the player types "n. n", and the first action
%% implies opening a door, which implies unlocking the door, and the unlocking
%% triggers a cutscene, then opening the door is cancelled, and the second "n"
%% is also ignored.

%% After a non-command action, time is advanced using (tick). This can be
%% inhibited by querying (inhibit next tick).

%% Throughout this procedure, as soon as a refuse or prevent rule succeeds (or
%% (stop) is invoked), the entire procedure stops, and further actions are
%% ignored.

(describe action $Action)
	(describe self-describing action $Action)

(describe self-describing action [])

%%TEST VERB

(describe self-describing action [(word $W) | $More])
	(just)
	(describe self-describing action $More)
	(verb)

(describe self-describing action [$Obj | $More])
	(den $Obj)
	(describe self-describing action $More)

(actions on)
	(now) (tracing actions)

(actions off)
	(now) ~(tracing actions)

(interface (try $<Action))

(try $Action)
	(if) (tracing actions) (then)
		(line) ACTION: $Action \( (describe action $Action) \) (line)
	(endif)
	~{ (refuse $Action) (stop) }
	(exhaust) *(before $Action)
	~{ (refuse $Action) (stop) }
	(instead of $Action)

(try $)
	%% Try always succeeds; this prevents accidental double-triggers.

(interface (first try $<Action))

(first try $Action)
	(line) \( erst (describe action $Action) \) (line)
	(try $Action)
	(tick)
	(par)

(refuse $Action)
	*($Obj is one of $Action)
	(object $Obj)
	~(direction $Obj)
	~(relation $Obj)
	{
		(when $Obj is not here)
		(or) (when $Obj is out of reach)
	}

(before $)	(fail)

(instead of $Action)
	~{ (prevent $Action) (tick) (stop) }
	(perform $Action)
	(exhaust) *(after $Action)

(prevent $)	(fail)

(perform $)

(after $)	(fail)

(interface (try-complex $<Action))

(try-complex [$Verb | $ComplexObjects])
	(if) ([] is one of $ComplexObjects) (then)
		Dir ist so etwas nicht bekannt! (line) (fail)
	(elseif) ([+ | $FirstMulti] is one of $ComplexObjects) (then)
		%% If at least two actions are implied,
		%% describe each one in turn.
		(if) ~{ *($Obj is one of $FirstMulti) (direction $Obj) } (then)
			(strip decorations from $FirstMulti into $Stripped)
			(notice player's $Stripped) %% Set 'them'.
		(endif)
		(exhaust) {
			*(expand complex objlist $ComplexObjects $ObjList)
			(line)(uppercase)(describe action [$Verb | $ObjList]):
			(try-decorated $Verb $ObjList)
		}
	(else)
		*(expand complex objlist $ComplexObjects $ObjList)
		(try-decorated $Verb $ObjList)
	(endif)

(try-decorated $Verb $ObjList)
	(strip decorations from $ObjList into $CleanList)
	(if)
		*($Obj is one of $CleanList)
		(object $Obj)
		~(direction $Obj)
		~(relation $Obj)
		~(room $Obj)
	(then)
		(notice player's $Obj)
	(endif)
	(exhaust) {
		*($Obj is one of $CleanList)
		(object $Obj)
		(now) ~($Obj is hidden)
	}
	($Action = [$Verb | $CleanList])
	(try $Action)
	(if) ~(command $Action) (then)
		(tick)
	(endif)
	(par)

(strip decorations from [] into [])

(strip decorations from [[a $Obj] | $MoreIn] into [$Obj | $MoreOut])
	(strip decorations from $MoreIn into $MoreOut)

(strip decorations from [$Obj | $MoreIn] into [$Obj | $MoreOut])
	(strip decorations from $MoreIn into $MoreOut)

(expand complex objlist [] [])
	(just)

(expand complex objlist [[+ | $ObjList] | $MoreIn] [$Obj | $MoreOut])
	(just)
	*($Obj is one of $ObjList)
	*(expand complex objlist $MoreIn $MoreOut)

(expand complex objlist [$Other | $MoreIn] [$Other | $MoreOut])
	*(expand complex objlist $MoreIn $MoreOut)

(unlikely-complex [$Verb | $ComplexObjList] $VeryLevel)
	*(expand complex objlist $ComplexObjList $SimpleObjList)
	(strip decorations from $SimpleObjList into $Stripped)
	(level $VeryLevel unlikely [$Verb | $Stripped])

(level 0 unlikely $Action)
	(unlikely $Action) (or)
	(very unlikely $Action) (or)
	(very very unlikely $Action)

(level 1 unlikely $Action)
	(very unlikely $Action) (or)
	(very very unlikely $Action)

(level 2 unlikely $Action)
	(very very unlikely $Action)
	
%% Current and nearby rooms are in scope, but they're rarely what the player
%% means. The following rules ensure that most actions that mention rooms
%% directly are considered unlikely.

(very unlikely [(room $) | $])
(very unlikely [$ | $More])
	(very unlikely $More)

%% Only report the unrecognized topic (@?) as a last resort.

(interface (very very unlikely $<Action))

(very very unlikely [? | $])
(very very unlikely [$ | $More])
	(very very unlikely $More)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Daemons

(inhibit next tick)
	(now) (inhibiting next tick)

(tick)
	(if) (inhibiting next tick) (then)
		(now) ~(inhibiting next tick)
	(else)
		(recompute visibility)
		(exhaust) *(on every tick)
	(endif)

%% Stories may add rules to this predicate, or to (on every tick in $):

(on every tick)
	(current room $Room)
	*(on every tick in $Room)

(on every tick)
	(if) (narrator's it is protected) (then)
		(now) ~(narrator's it is protected)
	(elseif) (player's it refers to $) (then)
		%% The narrator's it is short-lived, except when
		%% 'it' unambiguously refers to it.
		(now) ~(narrator's it refers to $)
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Non-player characters

%% (let $NPC take $Obj)		(narrate $NPC taking $Obj)
%% (let $NPC drop $Obj)		(narrate $NPC dropping $Obj)
%% (let $NPC wear $Obj)		(narrate $NPC wearing $Obj)
%% (let $NPC remove $Obj)	(narrate $NPC removing $Obj)
%% (let $NPC put $A $Rel $B)	(narrate $NPC putting $A $Rel $B)
%% (let $NPC open $Obj)		(narrate $NPC opening $Obj)
%% (let $NPC close $Obj)	(narrate $NPC closing $Obj)

%% (let $NPC climb $Obj)	(narrate $NPC climbing $Obj)
%% (let $NPC enter $Obj)	(narrate $NPC entering $Obj)
%% (let $NPC leave $Obj)	(narrate $NPC leaving $Obj)
%% (let $NPC go $Dir)		(narrate $NPC leaving $Room $Dir to $NewRoom)
%%				(narrate $NPC entering $Room from $OldRoom)

%% No checks are carried out -- only attempt an NPC action if it makes sense!

(interface (let $<NPC climb $<Obj))
(interface (narrate $<NPC climbing $<Obj))

(let $NPC climb $Obj)
	(if) (player can see $Obj) (then)
		(narrate $NPC climbing $Obj)
	(endif)
	(now) ($NPC is #on $Obj)

(narrate $NPC climbing $Obj)
	(Der $NPC) (setzt sich $NPC) auf (den $Obj).

(interface (let $<NPC close $<Obj))
(interface (narrate $<NPC closing $<Obj))

(let $NPC close $Obj)
	(if) (player can see $Obj) (then)
		(narrate $NPC closing $Obj)
	(endif)
	(now) ($Obj is closed)

(narrate $NPC closing $Obj)
	(Der $NPC) (schließt $NPC) (den $Obj).

(interface (let $<NPC drop $<Obj))
(interface (narrate $<NPC dropping $<Obj))

(let $NPC drop $Obj)
	(if) (player can see $NPC) (then)
		(narrate $NPC dropping $Obj)
	(endif)
	($NPC is $Rel $Loc)
	(now) ($Obj is $Rel $Loc)

(narrate $NPC dropping $Obj)
	(Der $NPC) (lässt $NPC) (den $Obj) fallen.

(interface (let $<NPC enter $<Obj))
(interface (narrate $<NPC entering $<Obj))

(let $NPC enter $Obj)
	(if) (player can see $Obj) (then)
		(narrate $NPC entering $Obj)
	(endif)
	(now) ($NPC is #in $Obj)

(narrate $NPC entering $Obj)
	(The $NPC) (steigt $NPC) in (den $Obj).

(interface (let $<NPC go $<Dir))
(interface (narrate $<NPC leaving $<OldRoom $<Dir to $<NewRoom))
(interface (narrate $<NPC entering $<NewRoom from $<OldRoom))

(let $NPC go $Dir)
	($NPC is in room $OldRoom)
	(from $OldRoom go $Dir to room $NewRoom)
	(if) (player can see $NPC) (then)
		(narrate $NPC leaving $OldRoom $Dir to $NewRoom)
	(endif)
	(now) ($NPC is #in $NewRoom)
	(if) (player can see $NPC) (then)
		(narrate $NPC entering $NewRoom from $OldRoom)
	(endif)

(narrate $Obj leaving $ $Dir to $NewRoom)
	(Der $Obj)
	(if) ($NewRoom is visited) (then)
		(if) ($Dir = #in) (then)
			(geht $Obj) in (den $NewRoom) hinein
		(elseif) ($Dir = #out) (then)
			(geht $Obj) zu (dem $NewRoom) hinaus
		(elseif) ($Dir is one of [#up #down]) (then)
			(geht $Obj) zu (dem $NewRoom) (to-adverb $Dir)
		(else)
			(sucht $Obj) (den $NewRoom) im (name $Dir) auf
		(endif)
	(else)
		(geht $Obj)
		(if) ($Dir is one of [#in #out]) (then)
			(to-adverb $Dir)
		(else)
			nach (to-adverb $Dir) 
		(endif)
	(endif)
	.

(narrate $Obj entering $NewRoom from $OldRoom)
	(Der $Obj)
	(if) (from $NewRoom go $Dir to room $OldRoom) (then)
		(if) ($OldRoom is visited) (then)
			(if) ($Dir = #out) (then)
				(kommt $Obj) von (dem $OldRoom) herein
			(elseif) ($Dir = #in) (then)
				(kommt $Obj) aus (dem $OldRoom) heraus
			(elseif) ($Dir is one of [#up #down]) (then)
				(kommt $Obj) von (dem $OldRoom) (to-adverb $Dir)
			(else)
				(kommt $Obj) von (dem $OldRoom) im (name $Dir)
			(endif)
		(else)
			(kommt $Obj) von (from-adverb $Dir) 
		(endif)
	(else)
		(Der $Obj) (kommt $Obj) aus (dem $OldRoom)
	(endif)
	.

(interface (let $<NPC leave $<Obj))
(interface (narrate $<NPC leaving $<Obj))

(let $NPC leave $Obj)
	(if) (player can see $Obj) (then)
		(narrate $NPC leaving $Obj)
	(endif)
	($Obj is $Rel $Loc)
	(now) ($NPC is $Rel $Loc)

(narrate $NPC leaving $Obj)
	(Der $NPC) (verlässt $NPC) (den $Obj).

(interface (let $<NPC open $<Obj))
(interface (narrate $<NPC opening $<Obj))

(let $NPC open $Obj)
	(if) (player can see $Obj) (then)
		(narrate $NPC opening $Obj)
	(endif)
	(now) ($Obj is open)

(narrate $NPC opening $Obj)
	(Der $NPC) (öffnet $NPC) (den $Obj).

(interface (let $<NPC put $<Obj $<Rel $<Dest))
(interface (narrate $<NPC putting $<Obj $<Rel $<Dest))

(let $NPC put $Obj $Rel $Dest)
	(if) (player can see $NPC) (then)
		(narrate $NPC putting $Obj $Rel $Dest)
	(endif)
	(now) ($Obj is $Rel $Dest)

(narrate $NPC putting $Obj $Rel $Dest)
	(Der $NPC) (legt $NPC) (den $Obj) (name $Rel) (den $Dest).

(interface (let $<NPC remove $<Obj))
(interface (narrate $<NPC removing $<Obj))

(let $NPC remove $Obj)
	($Obj is #wornby $NPC)
	(if) (player can see $NPC) (then)
		(narrate $NPC removing $Obj)
	(endif)
	(now) ($Obj is #heldby $NPC)

(narrate $NPC removing $Obj)
	(Der $NPC) (zieht $NPC) (den $Obj) aus.

(interface (let $<NPC take $<Obj))
(interface (narrate $<NPC taking $<Obj))

(let $NPC take $Obj)
	(if) (player can see $NPC) (then)
		(narrate $NPC taking $Obj)
	(endif)
	(now) ($Obj is #heldby $NPC)

(narrate $NPC taking $Obj)
	(Der $NPC) (nimmt $NPC) (den $Obj).

(interface (let $<NPC wear $<Obj))
(interface (narrate $<NPC wearing $<Obj))

(let $NPC wear $Obj)
	(if) (player can see $NPC) (then)
		(narrate $NPC wearing $Obj)
	(endif)
	(now) ($Obj is #wornby $NPC)

(narrate $NPC wearing $Obj)
	(Der $NPC) (zieht $NPC) (den $Obj) an.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Numbers

(interface (parse numeral $<Word into $>Number))

(parse numeral @null into 0)
(parse numeral @eins into 1)
(parse numeral @eine into 1)
(parse numeral @einen into 1)
(parse numeral @eines into 1)
(parse numeral @zwei into 2)
(parse numeral @drei into 3)
(parse numeral @vier into 4)
(parse numeral @fünf into 5)
(parse numeral @sechs into 6)
(parse numeral @sieben into 7)
(parse numeral @acht into 8)
(parse numeral @neun into 9)
(parse numeral @zehn into 10)
(parse numeral @elf into 11)
(parse numeral @zwölf into 12)
(parse numeral @dreizehn into 13)
(parse numeral @vierzehn into 14)
(parse numeral @fünfzehn into 15)
(parse numeral @sechzehn into 16)
(parse numeral @siebzehn into 17)
(parse numeral @achtzehn into 18)
(parse numeral @neunzehn into 19)
(parse numeral @zwanzig into 20)
(parse numeral $N into $N) (number $N)

(interface (understand $<Words as number $>Number))

(understand [$Word] as number $N)
	(parse numeral $Word into $N)

(interface (spell out $<Number))

(spell out 1)		ein
(spell out 2)		zwei
(spell out 3)		drei
(spell out 4)		vier
(spell out 5)		fünf
(spell out 6)		sechs
(spell out 7)		sieben
(spell out 8)		acht
(spell out 9)		neun
(spell out 10)		zehn
(spell out 11)		elf
(spell out 12)		zwölf
(spell out 13)		dreizehn
(spell out 14)		vierzehn
(spell out 15)		fünfzehn
(spell out 16)		sechszehn
(spell out 17)		siebzehn
(spell out 18)		achtzehn
(spell out 19)		neunzehn
(spell out 20)		zwanzig
(spell out $N)		$N

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 25: Printing the names of objects and object lists

(interface (ein $<Obj))
(interface (eines $<Obj))
(interface (einem $<Obj))
(interface (einen $<Obj))

(interface (der $<Obj))
(interface (des $<Obj))
(interface (dem $<Obj))
(interface (den $<Obj))

(interface (den full $<Obj))

(interface (Ein $<Obj))
(interface (Eines $<Obj))
(interface (Einem $<Obj))
(interface (Einen $<Obj))

(interface (Der $<Obj))
(interface (Des $<Obj))
(interface (Dem $<Obj))
(interface (Den $<Obj))

(interface (Der full $<Obj))

(interface (add location information for $<Obj))

(add location information for $Obj)
	(if) (clarify location of $Obj) ~(direction $Obj) ~(relation $Obj) (then)
		(if)
			(current room $Room)
			(from $Room go $Dir to $Obj)
			(direction $Dir)
		(then)
			(present-adverb $Dir)
		(elseif)
			($Obj is $Rel $Loc)
			~(room $Loc)
		(then)
			\((name $Rel) (dem $Loc)\)
		(endif)
	(endif)

(clarify location of (door $Obj))
	~(singleton $Obj)

(ein ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.
(eines ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.
(einem ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.
(einen ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.

(der ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.
(des ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.
(dem ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.
(den ($Obj is hidden))	(reveal $Obj) (fail) %% Proceed with normal handling.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 26: German signatures

(name $)

(fsyn $)
(msyn $)
(nsyn $)
(psyn $)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 27: German state of objects vocabulary

(Name $Obj)		(uppercase) (name $Obj)

(interface ($<Obj))

($Obj)
	(link) (name $Obj)

(interface ($<Obj $<Text))

($Obj $Text)
	(if) (interpreter supports links) (then)
		(collect words)
			(name $Obj)
		(into $Words)
		(link $Words) (query $Text)
	(else)
		(query $Text)
	(endif)

(maybe link $Obj)
	(if) (library links enabled) (then)
		(link) (name $Obj)
	(else)
		(name $Obj)
	(endif)

(maybe link $Obj $Closure)
	(if) (library links enabled) (then)
		(if) (current player $Obj) (then)
			(link [myself]) (query $Closure $Obj)
		(else)
			(link) (query $Closure $Obj)
		(endif)
	(else)
		(query $Closure $Obj)
	(endif)

(interface (open or closed $<Obj))

(open or closed $Obj)
	(if) ($Obj is open) (then)
		geöffnet
	(else)
		geschlossen
	(endif)

(einen-listing $List)
	(listing $List {(einen $_)} @und 0)

(der-listing $List)
	(listing $List {(der $_)} @und 0)
(des-listing $List)
	(listing $List {(des $_)} @und 0)
(dem-listing $List)
	(listing $List {(dem $_)} @und 0)
(den-listing $List)
	(listing $List {(den $_)} @und 0)

(den-full-listing $List)
	(listing $List {(den full $_)} @und 0)
(den-full-oder-listing $List)
	(listing $List {(maybe link $_ {(den full $_)})} @oder 0)
(den-oder-listing $List)
	(listing $List {(den $_)} @oder 0)

(ein-listing $List)
	(listing $List {(ein $_)} @und 0)

(listing [] $ $ 0)
	nichts
(listing [$Head | $Tail] $PrintClosure $Conjunction $NPrinted)
	(if) (fungibility enabled) (then)
		(combine-fungible $Tail $Head $NInc $Rest)
	(else)
		($Rest = $Tail)
	(endif)
	(if) (empty $Rest) (then)
		%%(if) ($NPrinted > 1) (then) , (endif)
		(if) ($NPrinted > 0) (then) $Conjunction (endif)
	(else)
		(length of $Rest into $len)
		(if) ($NPrinted > 0) (then)
			(if) ($len > 0) (then)
				,
			(endif) 
		(endif)
	(endif)
	(if) (fungibility enabled) ($NInc > 1) (then)
		(spell out $NInc)
		(if) (library links enabled) (interpreter supports links) (then)
			(link) (plural name $Head)
		(else)
			(plural name $Head)
		(endif)
	(else)
		(query $PrintClosure $Head)
	(endif)
	($NPrinted plus 1 into $NPp1)
	(if) (nonempty $Rest) (then)
		(listing $Rest $PrintClosure $Conjunction $NPp1)
	(endif)

(list of objects $Rel $Loc)
	(collect $Obj)
		*($Obj is $Rel $Loc)
	(into $List)
	(einen $List)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 28: Generating dictionary words for objects

(dict (your $))
	mein dein

(dict (openable $Obj))
	(if) ($Obj is open) (then)
		offen geöffnet
	(else)
		geschlossen
	(endif)

(dict (lockable $Obj))
	(if) ($Obj is locked) (then)
		verschlossen versperrt abgeschlossen
	(else)
		unverschlossen unversperrt aufgeschlossen
	(endif)

(dict (room $Room))
	(inherently dark $Room)
	~(light reaches ceiling $Room)
	finsternis dunkelheit

%% In German, no word mentioned in the name rule is included.
%% All name rules have special declination and adjective extensions
%% so this feature was removed

%% The plural dict should only mention a noun, so the default rule can't
%% invoke (plural name $).

(plural dict $)
	(fail)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 29: Setting the pronouns from an object

(interface (notice $<Obj))

(notice $Obj)
	(if) (object $Obj) (then)
		(reveal $Obj)
		(if) (plural $Obj) (or) ($Obj is plural) (or) (changing gender is #plu) (then)
			%%!Narrators plu!
			(now) (narrator's ihnen refers to [$Obj])
			(now) (narrator's sie refers to $Obj)
		(elseif) ($Obj is feminin) (or) (changing gender is #fem) (then)
			%%!Narrators fem!
			(now) (narrator's sie refers to $Obj)
			(now) (narrator's ihr refers to $Obj)
		(elseif) ($Obj is maskulin) (or) (changing gender is #mas) (then)
			%%!Narrators mas!
			(now) (narrator's ihn refers to $Obj)
			(now) (narrator's ihm refers to $Obj)
		(elseif) ($Obj is neutrum) (or) (changing gender is #neu) (then)
			%%!Narrators neu!
			(now) (narrator's es refers to $Obj)
			(now) (narrator's ihm refers to $Obj)
		(elseif) (female $Obj) (then)
			(now) (her refers to $Obj)
		(elseif) (male $Obj) (then)
			(now) (him refers to $Obj)
		(else)
			(now) (narrator's it refers to $Obj)
			(now) (narrator's it is protected)
			(if) (player's it refers to $Obj) (then)
				(now) ~(player's it refers to $)
			(endif)
		(endif)
	(elseif) (list $Obj) (then)
		(if) ($Obj = [$Single]) (then)
			(notice $Single)
		(else)
			(length of $Obj into $N)
			(if) ($N < 16) (then)
				(now) (narrator's ihnen refers to $Obj)
			(endif)
		(endif)
	(endif)

(notice player's $Obj)
	(if) ~(current player $Obj) (then)
		(if) ($Obj is plural) (then)
			(now) (player's ihnen refers to [$Obj])
			(now) (player's sie refers to $Obj)
		(elseif) (list $Obj) (then)
			(if) ($Obj = [$Single]) (then)
				(notice player's $Single)
			(else)
				(length of $Obj into $N)
				(if) ($N < 16) (then)
					(now) (player's ihnen refers to $Obj)
					(now) (player's sie refers to $Obj)
				(endif)
			(endif)
		(elseif) (changing gender is #fem) (then)
			%%!players CG FEM!
			(now) (player's sie refers to $Obj)
			(now) (player's ihr refers to $Obj)
		(elseif) (changing gender is #mas) (then)
			%%!players CG MAS!
			(now) (player's ihn refers to $Obj)
			(now) (player's ihm refers to $Obj)
		(elseif) (changing gender is #neu) (then)
			%%!players CG NEU!
			(now) (player's es refers to $Obj)
			(now) (player's ihm refers to $Obj)
		(elseif) (changing gender is #plu) (then)
			%%!players CG PLU!
			(now) (player's ihnen refers to $Obj)
			(now) (player's sie refers to $Obj)
		(elseif) ($Obj is feminin) (then)		
			%%!players FEM!
			(now) (player's sie refers to $Obj)
			(now) (player's ihr refers to $Obj)
		(elseif) ($Obj is maskulin) (then)
			%%!players MAS!
			(now) (player's ihn refers to $Obj)
			(now) (player's ihm refers to $Obj)
		(elseif) ($Obj is neutrum) (then)
			%%!players NEU!
			(now) (player's es refers to $Obj)
			(now) (player's ihm refers to $Obj)
		(elseif) ($Obj is plural) (then)
			%%!players PLU!
			(now) (player's ihnen refers to $Obj)
		(elseif) (female $Obj) (then)
			(now) (her refers to $Obj)
		(elseif) (male $Obj) (then)
			(now) (him refers to $Obj)
		(else)
			(now) (player's it refers to $Obj)
			(if) (narrator's it refers to $Obj) (then)
				(now) ~(narrator's it refers to $)
			(endif)
		(endif)
	(endif)

(clear all pronouns)
	(now) ~(player's es refers to $)
	(now) ~(narrator's es refers to $)
	(now) ~(player's ihn refers to $)
	(now) ~(narrator's ihn refers to $)
	(now) ~(player's sie refers to $)
	(now) ~(narrator's sie refers to $)
	(now) ~(player's ihm refers to $)
	(now) ~(narrator's ihm refers to $)
	(now) ~(player's ihr refers to $)
	(now) ~(narrator's ihr refers to $)
	(now) ~(player's ihnen refers to $)
	(now) ~(narrator's ihnen refers to $)

(forget pronouns out of scope)
	(if) (player's es refers to $Obj) ~($Obj is in scope) (then)
		(now) ~(player's es refers to $)
	(endif)
	(if) (narrator's es refers to $Obj) ~($Obj is in scope) (then)
		(now) ~(narrator's es refers to $)
	(endif)
	(if) (player's ihn refers to $Obj) ~($Obj is in scope) (then)
		(now) ~(player's ihn refers to $)
	(endif)
	(if) (player's ihm refers to $Obj) ~($Obj is in scope) (then)
		(now) ~(player's ihm refers to $)
	(endif)
	(if) (player's sie refers to $Obj) ~($Obj is in scope) (then)
		(now) ~(player's sie refers to $)
	(endif)
	(if) (player's ihr refers to $Obj) ~($Obj is in scope) (then)
		(now) ~(player's ihr refers to $)
	(endif)
	(if)
		(player's ihnen refers to $ObjList)
		*($Obj is one of $ObjList)
		~($Obj is in scope)
	(then)
		(now) ~(player's ihnen refers to $)
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 30: Default descriptions etc.

(descr (current player $))
	Nun ja, hier bist du.

(descr (door $Door))
	~($Door blocks light)
	(current room $Room)
	(from $Room through $Door to $R)
	Durch (den $Door) siehst du (den $R).

(descr (door $Door))
	(openable $Door)
	(Der $Door ist) im Moment (open or closed $Door).

(descr $O)
	(current room $Room)
	*(from $Room go $Dir to $O)
	(direction $Dir)
	(Der $O ist) weiter im (name $Dir).

(descr $Obj)
	(Er $Obj) (sieht $Obj) harmlos aus.

(look $Obj)
	($Obj has parent $Parent)
	(look $Parent)

(feel (room $))
	Du tastest deine Umgebung ab und bemerkst nichts Außergewöhnliches.

(feel $Obj)
	(Der $Obj) (fühlt sich $Obj) wie erwartet an.

(appearance (item $Obj) #in (room $Room))
	($Obj is handled)
	Du siehst hier (einen $Obj).
	(notice $Obj)

(appearance (item $Obj) $Rel $Loc)
	($Obj is handled)
	(Ein $Obj) (ist $Obj) (name $Rel) (dem $Loc).
	(notice $Obj)

(appearance (list $List) $Rel $Loc)
	(fungibility enabled)
	(if) ($Rel = #in) (room $Loc) (then)
		Du siehst hier (einen $List).
	(else)
		(Ein $List) sind (name $Rel) (dem $Loc).
	(endif)
	(notice $List)

(make appearances $Rel $Loc)
	(if)
		~{ ($Loc is opaque) ($Loc is closed) ($Rel = #in) }
		($Loc is $ParentRel $ParentLoc)
	(then)
		(make appearances $ParentRel $ParentLoc)
	(endif)
	(if) (fungibility enabled) (then)
		(collect $Obj)
			*($Obj is $Rel $Loc)
			~($Obj is hidden)
		(into $ObjList)
		(fungibility-enabled appearance $ObjList $Rel $Loc)
	(else)
		(exhaust) {
			*($Object is $Rel $Loc)
			~($Object is hidden)
			(par)
			(appearance $Object $Rel $Loc)
		}
	(endif)

(interface (list objects $<Rel $<Loc))

(list objects $Rel $Loc)
	(collect $Obj)
		*($Obj is $Rel $Loc)
	(into $List)
	(if) (nonempty $List) (then)
		(Name $Rel) (dem $Loc) (ist $List) (ein $List).
		(notice $List)
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 31: Fungibility

(fungibility enabled)	(fail)	%% Override this from the story.

(fungible $A $A)

(truly fungible $A $B)
	(fungible $A $B)
	($A is $Rel $Parent)
	($B is $Rel $Parent)

(combine-fungible [] $ 1 [])
(combine-fungible [$Head | $Tail] $Key $N $Excluded)
	(if) (truly fungible $Head $Key) (then)
		(combine-fungible $Tail $Key $NMore $Excluded)
		($NMore plus 1 into $N)
	(else)
		(combine-fungible $Tail $Key $N $MoreExcl)
		($Excluded = [$Head | $MoreExcl])
	(endif)

(strip-fungible [] [])
(strip-fungible [$HeadIn | $MoreIn] [$HeadOut | $MoreOut])
	(combine-fungible $MoreIn $HeadIn $N $Rest)
	(if) (1 < $N) (then)
		($HeadOut = [a $HeadIn]) %% Decorated.
	(else)
		($HeadOut = $HeadIn)
	(endif)
	(strip-fungible $Rest $MoreOut)

(fungibility-enabled appearance [] $ $)

(fungibility-enabled appearance [$Head | $Tail] $Rel $Loc)
	(combine-fungible $Tail $Head $NInc $Rest)
	(par)
	(if) ($NInc = 1) (then)
		(appearance $Head $Rel $Loc) (or)
	(else)
		(remove from $Tail matching $Rest into $Similar)
		(appearance [$Head | $Similar] $Rel $Loc)
	(endif)
	(fungibility-enabled appearance $Rest $Rel $Loc)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 32: Common complaints and prevent-checks

(when $O is out of sight)
	~(player can see $O)
	(if) (player can see) (then)
		Du siehst hier so etwas nicht.
	(else)
		Du siehst in der Dunkelheit zu wenig.
	(endif)

(when $O is already held)
	(current player $Actor)
	{
		($O is #heldby $Actor)
		Du hast (den $O) schon mitgenommen.
	(or)
		($O is recursively worn by $Actor)
		Du trägst (den $O) schon.
	}

(when $O isn't directly held)
	(current player $Actor)
	~($O is #heldby $Actor)
	Du hast (den $O) aber gar nicht.

(when $Obj is not here)
	(not here $Obj)
	(Der $Obj ist) nicht hier.

(when $O is out of reach)
	~($O is reachable by player)
	(if) (player can see $O) (then)
		Du kannst (den $O) nicht erreichen.
	(else)
		(Der $O ist) nicht hier.
	(endif)

(when (intangible $O) is out of reach)
	(Der $O ist) unerreichbar.

(when $O is part of something)
	($O is #partof $Parent)
	(Er $O) (ist $O) Teil (des $Parent).

(when $O is held by someone)
	($O is #heldby $Parent)
	(Der $O) (gehört $O) (dem $Parent).

(when $O is worn by someone)
	($O is #wornby $Parent)
	(Der $Parent) (hat $Parent) (den $O) angezogen.

(when $Obj is fine where it is)
	(fine where it is $Obj)
	(Der $Obj ist) da, wo (er $Obj) (ist $Obj), gut aufgehoben.

(when ~(item $O) can't be taken)
	Du kannst (den $O) nicht mitnehmen.

~(when (supporter $O) won't accept #on)

~(when (container $O) won't accept #in)

(when $O won't accept $Rel)
	(if) ($Rel is one of [#under #behind]) (then)
		Dinge (name $Rel) (den $O) zu legen, wird dich nicht weiter bringen.
	(else)
		Du kannt nichts (name $Rel) (den $O) legen.
	(endif)

~(when (actor supporter $O) won't accept actor #on)

~(when (actor container $O) won't accept actor #in)

(when $O won't accept actor $Rel)
	(if) ($Rel is one of [#under #behind]) (then)
		(uppercase)(name $Rel) (den $O) zu gelangen, wird dich nicht weiter bringen.
	(else)
		(uppercase)(name $Rel) (den $O) zu gelangen, ist unmöglich.
	(endif)

(when $O is already $Rel $Dest)
	($O is $Rel $Dest)
	(Der $O ist) schon (name $Rel) (dem $Dest).

(when $O is $Rel $Parent)
	($O is $Rel $Parent)
	(Der $O) (muss $O) erst (reverse-name $Rel) (dem $Parent) entfernt werden.

(when $Obj is closed)
	($Obj is closed)
	(Der $Obj ist) geschlossen.

(when $Obj blocks passage)
	($Obj blocks passage)
	(if) ($Obj is closed) (then)
		(Der $Obj ist) geschlossen.
	(else)
		(Der $Obj) (lässt $Obj) dich nicht vorbei.
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chpater 35: Program entry, main loop, status bar, score

(program entry point)
	(div @initial-spacer) {}
	(update environment around player)
	(stoppable) (intro)
	*(repeat forever) (par) (read-parse-act) (fail)

(intro)
	(banner)
	(try [look])

%% When the game asks a disambiguating question ("Did you ..."), and the player
%% types an unrecognized response, this needs to be parsed as a regular action
%% instead. If this happens several times in a row, the heap would fill up with
%% half-finished parsing attempts, and eventually overflow. To prevent this, we
%% store the unrecognized response in a global variable and backtrack (actually
%% stop) to recover heap space.

(global variable (deferred commandline $))

(read-parse-act)
	(if) (deferred commandline $Words) (then)
		(now) ~(deferred commandline $)
		(stoppable) {
			(parse commandline $Words)
		}
	(else)
		(stoppable) {
			(if)
				(scoring enabled)
				(score notifications are on)
			(then)
				(report score change)
			(endif)
			(redraw status bar)
			> (get input $Words)
			(parse commandline $Words)
		}
	(endif)

(report score change)
	(if) (scoring enabled) (score notifications are on) (then)
		(reported score is $Reported)
		(current score $Score)
		(if) ($Score < $Reported) (then)
			($Reported minus $Score into $Diff)
			\( Dein Punktestand hat sich um (spell out $Diff)
			verringert. \)
			(par)
			(now) (reported score is $Score)
		(elseif) ($Score > $Reported) (then)
			($Score minus $Reported into $Diff)
			\( Dein Punktestand hat sich um (spell out $Diff)
			erhöht. \)
			(par)
			(now) (reported score is $Score)
		(endif)
	(endif)

(redraw status bar)
	(status bar @status) {
		(score headline)
		(status headline)
	}

(redraw status bar)
	%% This predicate shouldn't fail.

(status headline)
	(location headline)

(location headline)
	(current player $Player)
	(if) (player can see) (then)
		(current room $Room)
		(span @bold) (room header $Room)
		($Player is $Rel $Loc)
		(if) ~{ ($Rel = #in) ($Loc = $Room) } (then)
			\( (name $Rel) (dem $Loc) \)
		(endif)
	(else)
		(span @bold) (darkness headline)
	(endif)

(darkness headline)
	In völliger Dunkelheit

(narrate darkness)
	Du bist von Dunkelheit umgeben.
	(current visibility ceiling $Ceil)
	(notice $Ceil)

(current score 0)
(reported score is 0)

(score notifications are on)
	(scoring enabled)

(interface (increase score by $<Delta))

(increase score by $Delta)
	(current score $Old)
	($Old plus $Delta into $New)
	(now) (current score $New)

(interface (decrease score by $<Delta))

(decrease score by $Delta)
	(current score $Old)
	($Old minus $Delta into $New)
	(now) (current score $New)

(score headline)
	(if) (scoring enabled) (then)
		(current score $Score)
		(div @score) {
			Score: $Score
			(if) (maximum score $Max) (then)
				von $Max
			(endif)
		}
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chpater 36: Banner and default metadata

%% There is no formal requirement to print the banner, but it's appreciated
%% and useful to the community and yourself.

(banner)
	(par)
	(div @title) (story title or default)
	(story noun) von (story author or default).
	(line)
	(additional banner text)
	(line)
	(story release $RelNum)
	Release $RelNum.
	Serial number (serial number).
	(line)
	(compiler version).
	(library version)
	(exhaust) { *(extension version) }
	(par)

%% Override to insert co-credits, dedications, etc. into the banner:

(additional banner text)

%% Library extensions can add their name and version number to the banner:

(extension version)	(fail)

%% The following predicates help to conserve space when a title or author is
%% provided. The compiler is smart enough to eliminate the second rule if the
%% first is known to succeed:

(story title or default)	(story title)
(story title or default)	Ein Textadventure

(story author or default)	(story author)
(story author or default)	Anonymus

%% Don't warn about querying these; however, this does not disable the warning
%% about them not being defined (for a sufficiently large story):

(story title)		(fail)
(story author)		(fail)

%% We can safely supply defaults for the following:

(story release 1)

(story noun)	
	Ein Textadventure

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chpater 37: Game over

(game over)
	(par)
	(game over status bar)
	(if) (scoring enabled) (then)
		(current score $Score)
		Das Spiel is zu Ende. Du hast $Score
		(if) ($Score = 1) (then) Punkt (else) Punkte (endif)
		(if) (maximum score $Max) (then)
			von maximal $Max
		(endif)
		erreicht.
		(par)
	(endif)
	*(repeat forever) (game over menu) (fail)

(interface (game over $<Closure))

(game over $Message)
	(par)
	(space 5)
	(span @bold) { \*\*\* (query $Message) \*\*\* }
	(game over)

(game over status bar)
	(status bar @status) {
		(score headline)
		Game Over
	}

(game over menu)
	(line)
	Möchtest du:
	(if) (interpreter supports undo) (then)
		(line) (space 5)
		mit 
		(if) (library links enabled) (then)
			(link) UNDO
		(else)
			UNDO
		(endif)
		den letzten Zug zurück nehmen,
	(endif)
	(line) (space 5)
	(if) (library links enabled) (then)
		(link) einen Spielstand LADEN,
	(else)
		einen Spielstand LADEN,
	(endif)
	(line) (space 5)
	(exhaust) {
		*(game over option)
		(line) (space 5)
	}
	(if) (interpreter supports quit) (then)
		das Spiel be(no space)
		(if) (library links enabled) (then)
			(link) ENDE(no space)
		(else)
			ENDE(no space)
		(endif)
		n,
		(line) (space 5)
	(endif)
	oder das Spiel neu
	(if) (library links enabled) (then)
		(link) START(no space)
	(else)
		START(no space)
	(endif)
	en?
	(line)
	> (get input $Words)
	(stoppable) (parse game over $Words)

(game over option)
	(amusing enabled)
	eine Liste mit
	(if) (library links enabled) (then)
		(link) LUSTIG
	(else)
		LUSTIG
	(endif)
	en Sachen sehen,

(interface (parse game over $<Words))

(parse game over [start/neustart])
	(restart)

(parse game over [lad/load/restore])
	(try [restore])

(parse game over [undo])
	(if) (undo) (or) (then)
		Letzter Undo-Versuch fehlgeschlagen.
	(endif)

(parse game over [amusing/lustig])
	(amusing enabled)
	(amusing)

(parse game over [q/quit/ende])
	(display quit message)
	(line)
	(quit)

(parse game over $)
	Bitte wähle eines der angebenen Wörter.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 33: Parser: Global variables

(global variable (reported score is $))
(global variable (last command was $))
(global variable (implicit action is $))

(global variable (player's it refers to $))
(global variable (narrator's it refers to $))
(global variable (her refers to $))
(global variable (him refers to $))
(global variable (them refers to $))

(global variable (current case $))
(global variable (current article $))

(global variable (player's es refers to $))
(global variable (narrator's es refers to $))
(global variable (player's ihn refers to $))
(global variable (narrator's ihn refers to $))
(global variable (player's sie refers to $))
(global variable (narrator's sie refers to $))
(global variable (player's ihm refers to $))
(global variable (narrator's ihm refers to $))
(global variable (player's ihr refers to $))
(global variable (narrator's ihr refers to $))
(global variable (player's ihnen refers to $))
(global variable (narrator's ihnen refers to $))

%% (global variable (es refers to $))
%%(global variable (ihn refers to $))
%%(global variable (ihm refers to $))
%%(global variable (sie refers to $))
%%(global variable (ihr refers to $))
%%(global variable (ihnen refers to $))

%% we offer a second way to print out action reports
%% in infinitive context in all describe action traits

%% (describe action [take $Obj])
%%	  (den full $Obj) (zu) nehmen

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% some hooks for describing actions "from scratch"
%% the library relies heavily on the "describe action" predicate so normally
%% all different verbs result in the same parser question in uncmplete actions

%% This design decision was made to simplify the output process (the parser doesn't
%% have to assume anything about objects in dative case).

%% However, in some rare cases the parser queston must extract the verb from
%% the players input, not to sound strange. This is the case for all "put"
%% action, so in put $obj $rel $dest uses the (verb) predicate to display
%% the verb typed by the player. This can be also adopted to new actions
%% if the desired.

%% Note, that in this case, the author must define any irregular verb (as
%% "nimm" must lead to infinitve "nehmen") to ensure the correct output.

(global variable (current verb $))

(irregular $ as $) (fail)
(irregular [nimm] as [nehmen])

(set verb [$Verb | $])
	(now) (current verb $Verb)

(verb)
	(current verb $Verb)
	(irregular [$Verb] as [$Regular])
	$Regular

(verb)
	(current verb $Verb)
	(split word $Verb into $Letters)
	(if) (last $Letters @e) (then)
		$Verb(no space)n
	(else)
		$Verb(no space)en
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

(describe infinitive action $Action)
	(now) (infinitive context)
	(describe action $Action)
	(now) ~(infinitive context)

~(infinitve context)

(zu)
	(if) (infinitive context) (then)
		zu
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% German chaniging gender

(global variable (changing gender is $))

#mas
#fem
#neu
#plu

#not

(changing gender is #not)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 34: Parser: Rewrite

(interface (rewrite $<WordsIn into $>WordsOut))

(rewrite [g] into [again])

%% Fallback rewrite rule does nothing.

(rewrite $A into $A)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% rewrite sentences with prep in last slot as
%% verb prep rest

(rewrite [$First | $Last] into $Corrected)
	*(split $Last anywhere into $Left and $Right)
	($Right is one of [[an] [auf] [aus] [ein] [auf] [hin] [weg] [um] [mit] [zu] [ab] [durch] [hoch] [fest] [locker] [fallen] [los]])
	(append [$First | $Right] $Left $Corrected)
	(set verb $Corrected)

(rewrite [$First | $Last] into $Corrected)
	*(split $Last anywhere into $Left and $Right)
	*(split $Left anywhere into $1L and $1R)
	($1R is one of [[an] [auf] [aus] [ein] [auf] [hin] [weg] [um] [zu] [ab] [durch] [hoch] [fest] [locker] [fallen] [los]])
	ERKANNT2
	(nth $Right 1 $Check)
	($Check is one of [mit])
	(append [$First | $1R ] $1L $New)
	(append $New $Right $Corrected)
	(set verb $Corrected)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 35: Parser: Directions

%% Directions are treated separately from other objects for performance
%% reasons. They are not in scope.

(interface (understand $<Words as direction $>DirList))

(understand $Words as direction $Output)
	(parse direction list $Words $ObjList)
	(mark multi-object $ObjList into $Output)

(parse direction list $Words [$Head | $Tail])
	*(split $Words by [, und] into $Left and $Right)
	(just)
	*(parse direction $Left $Head)
	*(parse direction list $Right $Tail)

(parse direction list $Words [$Dir])
	*(parse direction $Words $Dir)

(parse direction [to | $Words] $Dir)
	(just)
	*(parse direction $Words $Dir)

(parse direction [the | $Words] $Dir)
	(just)
	*(parse direction $Words $Dir)

(parse direction $Input $Dir)
	(nonempty $Input)
	(determine object $Dir)
		*(direction $Dir)
	(from words)
		*(dict $Dir)
	(matching all of $Input)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chpaetr 41: Parser: Objects

%% Nouns in complex actions are represented as:
%%	an object $Obj,
%%	a decorated object [a $Obj],
%%	a list of objects (possibly decorated) [+ $Obj1 $Obj2 ...], or
%%	an error code [], [,], [all]
%% No output or other side effects are produced by the following rules.
%% Policy/ExcludeList are ignored when there's just one matching object.
%% Ambiguous expressions result in backtracking.

(interface (understand $<Words as non-all object $>ObjList))
(interface (understand $<Words as single object $>Obj))
(interface (understand $<Words as object $>ObjList preferably $<Closure))
(interface (understand $<Words as single object $>Obj preferably $<Closure))
(interface (understand $<Words as object $>ObjList preferably child of $<Parent))
(interface (understand $<Words as object $>ObjList preferably takable))
(interface (understand $<Words as object $>ObjList preferably held))
(interface (understand $<Words as single object $>Obj preferably held))
(interface (understand $<Words as object $>ObjList preferably held excluding $<ExcludeObj))
(interface (understand $<Words as single object $>Obj preferably animate))
(interface (understand $<Words as object $>ObjList preferably worn))
(interface (understand $<Words as single object $>Obj preferably supporter))
(interface (understand $<Words as single object $>Obj preferably container))
(interface (understand $<Words as any object $>Obj))
(interface (understand $<Words as any object $>Obj preferably animate))
(interface (understand $<Words as any object $>Obj preferably $<Closure))

(understand $Words as non-all object $Output)
	*(parse $Words as object $Output {} [] 0)

(understand $Words as single object $Object)
	*(parse $Words as single object $Object {} [])

(understand $Words as object $Output preferably $Closure)
	*(parse $Words as object $Output $Closure [] 1)

(understand $Words as single object $Output preferably $Closure)
	*(parse $Words as single object $Output $Closure [])

(understand $Words as object $Output preferably child of $Parent)
	*(parse $Words as object $Output $Parent [] 1)

(understand $Words as object $Output preferably takable)
	*(parse $Words as object $Output {(takable $_)} [] 1)

(understand $Words as object $Output preferably held)
	(current actor $Actor)
	*(parse $Words as object $Output {($_ is #heldby $Actor)} [] 1)

(understand $Words as single object $Output preferably held)
	(current actor $Actor)
	*(parse $Words as single object $Output {($_ is #heldby $Actor)} [])

(understand $Words as object $Output preferably held excluding $ExcludeObj)
	(current actor $Actor)
	*(parse $Words as object $Output {
		($_ is #heldby $Actor)
		~($_ = $ExcludeObj)
	} [] 1)

(understand $Words as single object $Output preferably animate)
	*(parse $Words as single object $Output {(animate $_)} [1])
	%% [1] produces 'someone' instead of 'something' in error responses.

(understand $Words as object $Output preferably worn)
	(current actor $Actor)
	*(parse $Words as object $Output {($_ is #wornby $Actor)} [] 1)

(understand $Words as single object $Output preferably supporter)
	*(parse $Words as single object $Output {(supporter $_)} [])

(understand $Words as single object $Output preferably container)
	*(parse $Words as single object $Output {(container $_)} [])

(understand $Words as any object $Output)
	*(parse $Words as any object $Output {} [])

(understand $Words as any object $Output preferably animate)
	*(parse $Words as any object $Output {(animate $_)} [1])

(understand $Words as any object $Output preferably $Closure)
	*(parse $Words as any object $Output $Closure [])

(interface (takable $<Obj))

(takable (item $Obj))
	($Obj has relation $Rel)
	~($Rel is one of [#partof #heldby #wornby])

(interface (verify object policy $Policy $<Obj))

(verify object policy (object $Policy) $Obj)
	($Obj has parent $Policy)

(verify object policy (nonempty $Policy) $Obj)
	(query $Policy $Obj)

(interface (parse $<Words as object $>ObjList $Policy $<FailObj $<AllAllowed))

(parse $Words as object $Output $Policy $ $AllAllowed)
	*(split $Words by [but except] into $Left and $Right)
	*(parse noun list $Left as $BaseList $Policy $AllAllowed)
	*(parse negative noun $Right from $BaseList into $ObjList)
	(mark multi-object $ObjList into $Output)

(parse $Words as object $Output $Policy $ $AllAllowed)
	*(parse noun list $Words as $ObjList $Policy $AllAllowed)
	(mark multi-object $ObjList into $Output)

(parse $ as object $Someone $ $Someone $)
	(allowing parse errors)

(interface (parse $<Words as single object $>Obj $Policy $<FailObj))

(parse $Words as single object $Output $Policy $Someone)
	*(parse $Words as object $ObjList $Policy $Someone 0)
	(if) ($ObjList = [+ | $]) (then)
		(allowing parse errors)
		($Output = [,])
	(else)
		($Output = $ObjList)
	(endif)

(interface (parse $<Words as any object $>Obj $Policy $<FailObj))

(parse $Words as any object $Output $Policy $)
	(filter $Words into $Filtered)
	(nonempty $Filtered)
	(collect $Obj)
		(determine object $Obj)
			*(object $Obj)
			~(direction $Obj)
			~(relation $Obj)
			~($Obj is in scope) %% Prevent double matches due to next branch.
			~($Obj is hidden)
			($Obj is in room $Room)
			($Room is visited)
		(from words)
			*(dict $Obj)
		(matching all of $Filtered)
	(into $Candidates)
	(apply policy to $Candidates $Policy $ObjList)
	*($Output is one of $ObjList)

(parse $Words as any object $Output $Policy $Someone)
	%% The purpose of this branch is to support pronouns, as well
	%% as not-here objects that are in scope.
	*(parse $Words as single object $Output $Policy $Someone)
	~(room $Output)

(interface (mark multi-object $<ObjList into $>ComplexObj))

(mark multi-object [$Single] into $Single)
	~(word $Single)
(mark multi-object [$Head | $Tail] into [+ $Head | $Tail])
	(object $Head)
(mark multi-object $Other into $Other)

(parse noun list $Words as $ObjList $Policy $AllAllowed)
	(split $Words by [, und] into $Left and $Right)
	*(parse basic noun $Left as $LeftObj $Policy $AllAllowed)
	*(parse noun list $Right as $RightObj $Policy $AllAllowed)
	(append $LeftObj $RightObj $ObjList)

(parse noun list $Words as $ObjList $Policy $AllAllowed)
	*(parse basic noun $Words as $ObjList $Policy $AllAllowed)

(parse negative noun [$Number | $Words] from $BaseList into $Result)
	{
		($Number is one of [a an])
		($N = 1)
	(or)
		(parse numeral $Number into $N)
	}
	(just)
	(if) (empty $Words) (then)
		(take $N from $BaseList into $NegList)
	(else)
		*(parse indefinite $Words as $NegList $N {($_ is one of $BaseList)})
	(endif)
	(remove from $BaseList matching $NegList into $Result)

(parse negative noun $Words from $BaseList into $Result)
	*(parse object name $Words as $NegList 0 $BaseList [])
	(remove from $BaseList matching $NegList into $Result)

(interface (parse basic noun $<Words as $>ObjList $Policy $<AllAllowed))

(parse basic noun [der/die/das/den/dem/des | $Words] as $ObjList $Policy $AllAllowed)
	(just)
	*(parse basic noun $Words as $ObjList $Policy $AllAllowed)

(parse basic noun [mich/dich/mir/dir] as [$Obj] $ $)
	(current player $Obj)

(parse basic noun [hier/raum/ort/gebiet/umgebung/wand/wände] as [$Room] $ $)
	(current room $Room)

(parse basic noun [dies raum/ort/gebiet/umgebung] as [$Room] $ $)
	(current room $Room)

(parse basic noun [es/dies] as [$Obj] $ $)
	{
		(player's es refers to $Obj)
	(or)
		(narrator's es refers to $Obj)
	}

(parse basic noun [ihn/diesen] as [$Obj] $ $)
	{
		(player's ihn refers to $Obj)
	(or)
		(narrator's ihn refers to $Obj)
	}

(parse basic noun [sie/diese] as [$Obj] $ $)
	{
		(player's sie refers to $Obj)
	(or)
		(narrator's sie refers to $Obj)
	}

(parse basic noun [ihm/diesem] as [$Obj] $ $)
	{
		(player's ihm refers to $Obj)
	(or)
		(narrator's ihm refers to $Obj)
	}

(parse basic noun [ihr/dieser] as [$Obj] $ $)
	{
		(player's ihr refers to $Obj)
	(or)
		(narrator's ihr refers to $Obj)
	}

(parse basic noun [ihnen/diesen/diese/sie] as ObjList $ $)
	{
		(player's ihnen refers to $ObjList)
	(or)
		(narrator's ihnen refers to $ObjList)
	}

(parse basic noun [alle] as [all] $ 0)
	(allowing parse errors)
	(just)

(parse basic noun [alle] as $Result (object $Policy) 1)
	(just)
	(collect $Obj)
		*($Obj has parent $Policy)
		($Obj is in scope)
		~($Obj is hidden)
		~(excluded from all $Obj)
	(into $Result)

(parse basic noun [alle] as $Result (nonempty $Policy) 1)
	(just)
	(collect $Obj)
		*($Obj is in scope)
		~(excluded from all $Obj)
		~($Obj is hidden)
		(verify object policy $Policy $Obj)
	(into $Result)

(parse basic noun [alle/jed/jeglich | $Words] as $ObjList $Policy $)
	*(parse object name $Words as $ObjList 1 $Policy)

(parse basic noun [ein/irgendein/einige | $Words] as $ObjList $Policy $)
	*(parse indefinite $Words as $ObjList 1 $Policy)

(parse basic noun [$Number | $Words] as $ObjList $Policy $)
	(nonempty $Words)
	(parse numeral $Number into $N)
	*(parse indefinite $Words as $ObjList $N $Policy)

(parse basic noun $Words as $ObjList $Policy $)
	%% This is the common case.
	*(parse object name $Words as $ObjList 0 $Policy)

(parse indefinite $Words as $Result $Limit $Policy)
	*(parse object name $Words as $ObjList 1 $Policy)
	(if) ($Limit = 1) ($ObjList = [$First $ | $]) (then)
		($Result = [[a $First]]) %% Decorate the result.
	(else)
		(take $Limit from $ObjList into $Result)
		(nonempty $Result)
	(endif)

(interface (parse object name $<Words as $>ObjList $<AllFlag $Policy))

(parse object name $Words as $Result $All $Policy)

	(filter $Words into $Filtered)
	(nonempty $Filtered)
	(collect $Obj)
		%% catch expressions like 'open the eastern window'
		($Filtered = [$Head | $Tail])
		(nonempty $Tail)
		(parse direction [$Head] $Dir)
		(current room $Room)
		(determine object $Obj)
			*(from $Room go $Dir to object $Obj)
			~(direction $Obj)
			~(relation $Obj)
			(words $Tail sufficiently specify $Obj)
		(from words)
			*(dict $Obj)
		(matching all of $Tail)
	(or)
		%% this is the normal case
		(determine object $Obj)
			*($Obj is in scope)
			~(direction $Obj)
			~(relation $Obj)
			(words $Filtered sufficiently specify $Obj)
		(from words)
			*(dict $Obj)
		(or)
			*(plural dict $Obj)
		(matching all of $Filtered)
	(into $Candidates)
	(nonempty $Candidates)
	(apply policy to $Candidates $Policy $CleanList)
	(if)
		%% Optimize for the common case.
		($CleanList = [$])
	(or)
		%% E.g. get all wooden.
		($All = 1)
	(or)
		%% A plural word causes all matching objects to be returned.
		*($PluralWord is one of $Filtered)
		(determine object $PObj)
			*($PObj is one of $CleanList)
		(from words)
			*(plural dict $PObj)
		(matching all of [$PluralWord])
	(then)
		($Result = $CleanList)
	(else)
		%% Backtrack over each matching object, for disambiguation.
		(if) (fungibility enabled) (then)
			(strip-fungible $CleanList $UniqueList)
			*($Obj is one of $UniqueList)
			($Result = [$Obj])
		(else)
			*($Obj is one of $CleanList)
			($Result = [$Obj])
		(endif)
	(endif)
	%% TEST PRONOUN CHANGING GENDER
	*($CGWord is one of $Filtered)
	*($CG is one of $Result)
	{
		(collect words)
			*(fsyn $CG)
		(into [$CGWord])
		%%Feminin!
		(now) (changing gender is #fem)
	(or)
		(collect words)
			*(msyn $CG)
		(into [$CGWord])
		%%Maskulin!
		(now) (changing gender is #mas)
	(or)
		(collect words)
			*(nsyn $CG)
		(into [$CGWord])
		%%Neutrum!
		(now) (changing gender is #neu)
	(or)
		(collect words)
			*(psyn $CG)
		(into [$CGWord])
		%%Plural!
		(now) (changing gender is #plu)
	(or)
		%%CG Reset! Regular!
		(now) (changing gender is #not)
	}

(interface (words $<Words sufficiently specify $<Obj))

(words $ sufficiently specify $)
	~(head noun is required)

(words $Words sufficiently specify $Obj)
	(collect words)
		(heads $Obj)
	(into $Heads)
	(if) (nonempty $Heads) (then)
		*($H is one of $Heads)
		($H is one of $Words)
	(endif)

(interface (filter $<WordsIn into $>WordsOut))

(filter [] into [])
	(just)

(filter [von | $MoreIn] into $MoreOut)
	(just)
	(filter $MoreIn into $MoreOut)

(filter [aus | $MoreIn] into $MoreOut)
	(just)
	(filter $MoreIn into $MoreOut)

(filter [$Other | $MoreIn] into [$Other | $MoreOut])
	(filter $MoreIn into $MoreOut)

(interface (apply policy to $<ObjsIn $Policy $>ObjsOut))

(apply policy to $Input $Policy $Output)
	(collect $Obj)
		*($Obj is one of $Input)
		(verify object policy $Policy $Obj)
	(into $Output)
	(nonempty $Output)

(apply policy to $Input $ $Input)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chpater 42: Topics

(describe topic @?)
	etwas

(describe topic $Topic)
	($Topic = [, | $])
	(dem full $Topic)

(describe topic (object $Obj))
	(dem full $Obj)

(describe topic $)
	einem bestimmten Thema

(proper *(proper topic $))
(topic *(proper topic $))
	
(proper topic $)
	(fail)
	
(interface (understand $<Words as topic $>Topic))

(understand $Words as topic $Obj)
	(filter $Words into $Filtered)
	(determine object $Obj)
		*(topic $Obj)
	(from words)
		*(dict $Obj)
	(matching all of $Filtered)

(describe person (object $Obj))
	(den full $Obj)

(describe person $)
	jemanden

(describe dative person (object $Obj))
	(dem full $Obj)

(describe dative person $)
	jemandem

(understand $Words as topic $Obj)
	*(understand $Words as single object $Obj)

(understand $WordList as topic $Topic)
	*($Word is one of $WordList)
	(topic keyword $Word implies $Topic)

(understand $ as topic @?)

(interface (topic keyword $<Word implies $>Topic))

(topic keyword $Keyword implies $Keyword)
	(topic keyword $Keyword)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 36: Parser: Toplevel

%% Parse and attempt each action in turn, and abort if one fails.
%% That's because an action may modify the scope, which affects the parsing of
%% subsequent actions.

(global variable (current actor $))

(interface (parse commandline $<Words))

(parse commandline [])
	Wie bitte?

(parse commandline [\* | $])
	%% By convention used by testers to put comments in a transcript.

(parse commandline $Words)
	(now) ~(allowing parse errors)
	(rebuild scope)
	(parse action sequence $Words)

(interface (parse action sequence $<Words))

(parse action sequence $Words)
	(if) (split $Words by [. ; dann] into $Left and $Right) (then)
		(parse action $Left)
		(rebuild scope)
		(parse action sequence $Right)
	(else)
		(parse action $Words)
	(endif)

(interface (parse action $<Words))

(parse action [])

(parse action $Words)

	%%VERB TEST
	%% Very First, try to get the verb

	($Words = [$Verb | $])
	(now) (current verb $Verb)

	%% First, check for UNDO.

	(if) ($Words = [undo]) (then)
		(if) ~(interpreter supports undo) (then)
			Dieser Interpreter unterstützt kein Undo.
		(elseif) (undo) (then)
			Zug zurück nehmen fehlgeschlagen!
		(else)
			Du kannst keine weiteren Züge zurück nehmen!
		(endif)
		(stop)
	(else)
		%% The command wasn't UNDO.
		%% Before proceeding, save the current undo state:

		(if) (save undo 1) (then)
			(roman)
			Letzter Zug zurück genommen.
			(line)
			(location headline)
			(stop)
		(endif)

		%% Usually, the player is the actor.
		(current player $Player)
		(now) (current actor $Player)

		%% Handle AGAIN, OOPS, and rewriting:

		(if)
			($Words = [$W])
			($W is one of [again g])
			(last command was $LastCmd)
		(then)
			(rewrite $LastCmd into $ActualWords)
		(elseif) ($Words = [äh $GoodWord]) (then)
			(if)
				(last command was $LastCmd)
				(correct $LastCmd with $GoodWord into $GoodCmd)
			(then)
				(now) (last command was $GoodCmd)
				(rewrite $GoodCmd into $ActualWords)
			(else)
				\(Eentschuldige, Ich habe kein Ahnung worauf sich "Äh" bezieht. \)
				(stop)
			(endif)
		(else)
			(now) (last command was $Words)
			(rewrite $Words into $ActualWords)
		(endif)

		%% Parse the action:

		(now) ~(head noun is required)
		(collect $A)
			*(understand $ActualWords as $A)
		(into $AllCandidatesWithDup)

		%% Since we may have multiple matches, do some sieving:

		(remove duplicates $AllCandidatesWithDup $AllCandidates)
		(if) ($AllCandidates = [$Single]) (then)
			%% Optimize the common case.
			(now) ~(implicit action is $)
			(now) ~(implicit action wants direction)
			(try-complex $Single)
		(elseif) (empty $AllCandidates) (then)
			%% We were unable to parse the action.

			%% Occasionally people like to separate actions by
			%% commas or 'AND', but this is problematic. We can
			%% only deal with it as a last resort, because in order
			%% to parse the part after the separator, we need to
			%% have the right scope, and therefore we first have to
			%% execute what's to the left of the separator.

			(if)
				*(split $ActualWords by [, und]
					into $Left and $Right)
				*(understand $Left as $)
			(then)
				(parse action $Left)
				(rebuild scope)
				(parse action $Right)
			(else)
				%% Everything has failed. Can we understand a
				%% partial action, in order to print an
				%% informative error message?

				(parse partial action $ActualWords)
			(endif)
		(else)
			(now) ~(implicit action is $)
			(now) ~(implicit action wants direction)
			(sieve action candidates $AllCandidates $ActualWords 0)
		(endif)
	(endif)

(correct [$BadWord | $More] with $GoodWord into [$GoodWord | $More])
	(unknown word $BadWord)
(correct [$Head | $TailIn] with $GoodWord into [$Head | $TailOut])
	(correct $TailIn with $GoodWord into $TailOut)

(parse partial action $Words)
	%% The multi-query inside the if-condition is unnecessary
	%% (if-conditions are only evaluated once), but the compiler is able to
	%% opmitize predicates better if they're consistently queried in the
	%% same mode.

	(now) (allowing parse errors)
	(if) *(understand $Words as $BadAction) (then)
		(if) ([all] is one of $BadAction) (then)
			\( "Alles" ist hier nicht möglich.
			Bitte genauer angeben. \)
		(elseif) ([,] is one of $BadAction) (then)
			\( Hier sind mehrere Objekte nicht möglich, bitte
			Schritt für Schritt angeben. \)
		(else)
			\( Ich habe dich nur soweit verstanden, du willst
			(describe action $BadAction)
			. \)
		(endif)
	(else)
		\( Ich habe ich dich leider nicht verstanden. \)
	(endif)
	(stop)

(sieve action candidates $AllCandidates $Words $VeryLevel)
	(if) ($VeryLevel = 3) (then)
		($LikelyCandidates = $AllCandidates)
	(else)
		(collect $A)
			*($A is one of $AllCandidates)
			~(unlikely-complex $A $VeryLevel)
		(into $LikelyCandidates)
	(endif)
	(if) (nonempty $LikelyCandidates) (then)
		%% Consider only the likely candidates.
		(consider action candidates $LikelyCandidates $Words)
	(else)
		%% All candidates were deemed unlikely, but some candidates
		%% could be more unlikely than the others.
		($VeryLevel plus 1 into $NextLevel)
		(sieve action candidates $AllCandidates $Words $NextLevel)
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 37: Disambiguation

(consider action candidates $List $Words)
	(if) ($List = [$Single]) (then)
		%% Optimize the common case.
		(try-complex $Single)
	(else)
		%% Eliminate options where the head noun is missing.
		(now) (head noun is required)
		(collect $A)
			*(understand $Words as $A)
			($A is one of $List)
		(into $ShortListWithDup)
		(remove duplicates $ShortListWithDup $ShortList)
		(if) ($ShortList = [$Single]) (then)
			(try-complex $Single)
		(else)
			(if) (empty $ShortList) (then)
				(disambiguate action $List $ComplexAction)
			(else)
				(disambiguate action $ShortList $ComplexAction)
			(endif)
			(try-complex $ComplexAction)
		(endif)
	(endif)

(disambiguate action $List $Result)
	(collect $Action)
		*($Action is one of $List)
		~{
			*($Action recursively contains $Obj)
			($Obj is hidden)
		}
	(into $NonSpoilery)
	(if) (empty $NonSpoilery) (then)
		($AskList = $List)
	(else)
		($AskList = $NonSpoilery)
	(endif)
	(if) ($AskList = [$Single]) (then)
		($Result = $Single)
	(elseif)
		(rephrase as object disambiguation
			$AskList
			$ComplexAction
			$Template
			$ObjList)
	(then)
		Willst du (describe action $ComplexAction)?
		(par)
		> (get input $Words)
		{
			(now) (head noun is required)
			(disambiguate by object name $Words $Template $ObjList $Result)
		(or)
			(now) ~(head noun is required)
			(disambiguate by object name $Words $Template $ObjList $Result)
		(or)
			(now) (deferred commandline $Words)
			(stop)
		}
	(else)
		Willst du: (line)
		(enumerate actions $AskList 1 $)
		(if) ~{ (library links enabled) (interpreter supports links) } (then)
			\( Gib die entsprechende Nummer ein\)
		(endif)
		(par)
		> (get input $Words)
		{
			(understand $Words as number $N)
			($N > 0)
			(nth $AskList $N $Result)
		(or)
			(now) (deferred commandline $Words)
			(stop)
		}
	(endif)

(disambiguate by object name [mich/mir/dich/dir] $Template $ObjList $Result)
	(current player $Player)
	($Player is one of $ObjList)
	(recover implicit action $Template $Player into $Result)

(disambiguate by object name $Words $Template $ObjList $Result)
	%% Since the player was given an explicit list of '(the full $)'
	%% descriptions, we have to match against those, in addition to the
	%% normal dict rules.

	(collect $A)
		(determine object $Obj)
			*($Obj is one of $ObjList)
			~(direction $Obj)
			~(relation $Obj)
			(words $Words sufficiently specify $Obj)
		(from words)
			(den full $Obj)
		(matching all of $Words)
		(recover implicit action $Template $Obj into $A)
	(into $Candidates)
	(nonempty $Candidates) %% otherwise fail into the next rule
	{
		($Candidates = [$Result])
	(or)
		(disambiguate action $Candidates $Result)
	}

(disambiguate by object name $Words $Template $ObjList $Result)
	(collect $A)
		(determine object $Obj)
			*($Obj is one of $ObjList)
			~(direction $Obj)
			~(relation $Obj)
			(words $Words sufficiently specify $Obj)
		(from words)
			*(dict $Obj)
		(matching all of $Words)
		(recover implicit action $Template $Obj into $A)
	(into $Candidates)
	(nonempty $Candidates)
	{
		($Candidates = [$Result])
	(or)
		(disambiguate action $Candidates $Result)
	}

(rephrase as object disambiguation [$Head | $Tail] $Complex $Template $ObjList)
	(all identical except object $Head $Tail $Pos [] $ObjList)
	(replace nth $Head $Pos [, | $ObjList] $Complex)
	(replace nth $Head $Pos [] $Template)

(replace nth [$ | $Tail] 1 $Element [$Element | $Tail])

(replace nth [$Head | $Tail] $N $Element [$Head | $SubOutput])
	($N minus 1 into $Nm1)
	(replace nth $Tail $Nm1 $Element $SubOutput)

(all identical except object $First [] $ObjPos $ObjIn [$LastObj | $ObjIn])
	(number $ObjPos)
	(nth $First $ObjPos $LastObj)

(all identical except object $First [$Second | $More] $ObjPos $ObjIn $ObjOut)
	(identical except object $First $Second 1 $ObjPos $FirstObj)
	(all identical except object
		$First
		$More
		$ObjPos
		[$FirstObj | $ObjIn]
		$ObjOut)

(identical except object [$H1 | $T1] [$H2 | $T2] $CurrPos $TargetPos $O1)
	(if) (object $H1) (object $H2) ~($H1 = $H2) (then)
		($CurrPos = $TargetPos)
		($O1 = $H2)
		($T1 = $T2)
	(else)
		($H1 = $H2)
		($CurrPos plus 1 into $NextPos)
		(identical except object $T1 $T2 $NextPos $TargetPos $O1)
	(endif)

(enumerate action $N $Action)
	(library links enabled)
	$N . (link [$N]) (describe action $Action)

(enumerate action $N $Action)
	$N . (describe action $Action)

(enumerate actions [$Item1 $Item2] $N $Np1)
	(just)
	(enumerate action $N $Item1) oder (line)
	($N plus 1 into $Np1)
	(enumerate action $Np1 $Item2) ? (line)
(enumerate actions [$Item1 $Item2 | $] 9 10)
	(just)
	(enumerate actions [$Item1 $Item2] 9 10)
	\(List truncated.\) (line)
(enumerate actions [$Head | $Tail] $N $Last)
	(enumerate action $N $Head) , (line)
	($N plus 1 into $Np1)
	(enumerate actions $Tail $Np1 $Last)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Asking for clarification

(interface (asking for object in $<Action))

(asking for object in $Action)
	(now) (implicit action is $Action)
	(now) ~(implicit action wants direction)
	(stop)

(interface (asking for direction in $<Action))

(asking for direction in $Action)
	(now) (implicit action is $Action)
	(now) (implicit action wants direction)
	(stop)

(recover implicit action [] $ into [])

(recover implicit action [[] | $More] $Obj into [$Obj | $More])

(recover implicit action [$Other | $MoreIn] $Obj into [$Other | $MoreOut])
	(recover implicit action $MoreIn $Obj into $MoreOut)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 39: Miscellaneous input routines

%% Asking a yes/no question:

(yesno)
	(space) > (get input $Words)
	(if) ($Words = [ja]) (or) ($Words = [j]) (or) ($Words = [ok]) (or) ($Words = [jo]) (then)
	(elseif) ($Words = [nein]) (or) ($Words = [n]) (or) ($Words = [nö]) (or) ($Words = [nee]) (then)
		(fail)
	(else)
		Bitte antworte mit ja oder nein
		(yesno)
	(endif)

%% Asking for a number:

(interface (get number from $<First to $<Last $>Number))

(get number from $First to $Last $N)
	$First - $Last > (get input $Input)
	(understand $Input as number $N)
	~($N < $First)
	~($N > $Last)

%% Waiting for a keypress:

(any key)
	(get key $)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Finding the shortest path from one room to another, using obvious exits.

(interface (shortest path from $<Room1 to $<Room2 is $>DirList))

(shortest path from $A to $B is $Path)
	($B is visited)
	(find paths starting at $A)
	(build path from $A to $B [] $Path)

(interface (first step from $<Room1 to $<Room2 is $>Dir))

(first step from $A to $B is $Dir)
	($B is visited)
	(find paths starting at $A)
	(reconstruct first hop $Dir from $A to $B)

(find paths starting at $Start)
	(exhaust) {
		*(room $R)
		(now) ~(last hop before $R is $)
	}
	(now) (last hop before $Start is [])
	(exhaust) {
		%% Explore the room graph starting from $A, set the last-hop
		%% variables, and fail when there are no rooms left.
		(elaborate paths from [$Start])
	}

(elaborate paths from $RoomList)
	(nonempty $RoomList)
	(collect $R)
		*($Here is one of $RoomList)
		{
			*(from $Here go $ to $R)
			(room $R)
		(or)
			*(from $Here through $Door to $R)
			~($Door blocks passage)
		}
		($R is visited)
		~(last hop before $R is $)
		(now) (last hop before $R is $Here)
	(into $NextGen)
	(elaborate paths from $NextGen)

%% Rooms have no locations, so '($ has relation $)' is unused for rooms.
%% We can repurpose it for path finding, to save RAM:

@(last hop before $A is $B) ($A has relation $B)

%% Reconstruct the full path from the 'last hop' links:

(build path from $Start to $End $SoFar $Path)
	(last hop before $End is $Last)
	(if) (empty $Last) (then)
		($Path = $SoFar)
	(else)
		(from $Last go $Dir to room $End)
		(build path from $Start to $Last [$Dir | $SoFar] $Path)
	(endif)

%% Reconstruct just the first hop:

(reconstruct first hop $Dir from $Start to $End)
	(last hop before $End is $Last)
	(if) ($Last = $Start) (then)
		(from $Start go $Dir to room $End)
	(else)
		(reconstruct first hop $Dir from $Start to $Last)
	(endif)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Updating and traversing the object tree

@($Obj is $Rel $Parent)
	%% The order of the following queries is critical when $Obj is unbound.
	*($Obj has parent $Parent)
	*($Obj has relation $Rel)

@($Obj is nowhere)
	~($Obj has parent $)

%% Determine what room ultimately surrounds a particular object:

(interface ($<Obj is in room $>Room))

((room $Room) is in room $Room)

($Obj is in room $Room)
	($Obj has parent $Loc)
	($Loc is in room $Room)

%% The following three predicates may be called with either parameter unbound.
%% They will traverse the object tree in the most efficient way for each case.

(interface ($>Obj has ancestor $>Ancestor))

($Obj has ancestor $Ancestor)
	(if) (bound $Obj) (then)
		($Obj has parent $Parent)
		{
			($Parent = $Ancestor) (or)
			*($Parent has ancestor $Ancestor)
		}
	(else)
		*($Sub has parent $Ancestor)
		{
			($Obj = $Sub) (or)
			*($Obj has ancestor $Sub)
		}
	(endif)

(interface ($>Obj is nested $>Rel $>Loc))

($Obj is nested $Rel $Loc)
	(if) (bound $Obj) (then)
		($Obj has parent $Parent)
		{
			($Obj has relation $Rel)
			($Parent = $Loc)
		(or)
			*($Parent is nested $Rel $Loc)
		}
	(else)
		*($Sub is $Rel $Loc)
		{
			($Obj = $Sub) (or)
			*($Obj has ancestor $Sub)
		}
	(endif)

($Obj is part of $Ancestor)
	(if) (bound $Obj) (then)
		($Obj is #partof $Parent)
		{
			($Parent = $Ancestor) (or)
			*($Parent is part of $Ancestor)
		}
	(else)
		*($Sub is #partof $Ancestor)
		{
			($Obj = $Sub) (or)
			*($Obj is part of $Sub)
		}
	(endif)

(interface ($<Obj is recursively worn by $<Actor))

($Obj is recursively worn by $Actor)
	($Obj is #wornby $Actor)

($Obj is recursively worn by $Actor)
	($Obj is #partof $OtherObj)
	($OtherObj is recursively worn by $Actor)

%% The following predicates are useful when writing before-rules:

(interface (ensure $<Obj is held))

(ensure $Obj is held)
	(current player $Actor)
	(if) ($Obj is recursively worn by $Actor) (then)
		(first try [remove $Obj])
	(elseif) (item $Obj) ~($Obj is #heldby $Actor) (then)
		(first try [take $Obj])
	(endif)

(recursively leave non-vehicles)
	(current player $Actor)
	($Actor has parent $Obj)
	~(room $Obj)
	~(vehicle $Obj)
	(first try [leave $Obj])
	(recursively leave non-vehicles)

(recursively leave descendants of $Obj)
	(current player $Actor)
	($Actor has parent $FirstObj)
	~($FirstObj = $Obj)
	(first try [leave $FirstObj])
	(recursively leave descendants of $Obj)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 42: List manipulation

(remove from [] matching $ into [])
	(just)
(remove from [$In | $MoreIn] matching $Keys into $MoreOut)
	($In is one of $Keys)
	(just)
	(remove from $MoreIn matching $Keys into $MoreOut)
(remove from [$In | $MoreIn] matching $Keys into [$In | $MoreOut])
	(remove from $MoreIn matching $Keys into $MoreOut)

(interface (remove duplicates $<Input $>Output))

(remove duplicates [] [])
	(just)
(remove duplicates [$Head | $MoreIn] $MoreOut)
	($Head is one of $MoreIn)
	(just)
	(remove duplicates $MoreIn $MoreOut)
(remove duplicates [$Head | $MoreIn] [$Head | $MoreOut])
	(remove duplicates $MoreIn $MoreOut)

(interface (length of $List into $>Number))

(length of [] into 0)
(length of [$ | $More] into $Np1)
	(length of $More into $N)
	($N plus 1 into $Np1)

(interface (nth $List $<Index $Element))

(nth [$Head | $] 1 $Head)
(nth [$ | $Tail] $N $Result)
	($N minus 1 into $Nm1)
	(nth $Tail $Nm1 $Result)

(last [$Last] $Last)
(last [$ | $Tail] $Last)
	(last $Tail $Last)

(take 0 from $ into [])
(take $N from [$Head | $MoreIn] into [$Head | $MoreOut])
	($N minus 1 into $Nm1)
	(take $Nm1 from $MoreIn into $MoreOut)

(interface ($<List1 contains one of $<List2))

($X contains one of $Y)
	(split $X by $Y into $ and $)

(interface ($<List1 contains sublist $<List2))

($ contains sublist [])
($List contains sublist [$Head | $Tail])
	(split $List by [$Head] into $ and $Rest)
	(append $Tail $ $Rest)

($List recursively contains $Element)
	*($Obj is one of $List)
	{
		($Obj = $Element)
	(or)
		(nonempty $Obj)
		($Obj recursively contains $Element)
	}

(reverse $Input $Output)
	(reverse-sub $Input $Output [])

(reverse-sub [] $Output $Output)
(reverse-sub [$Head | $Tail] $Output $SoFar)
	(reverse-sub $Tail $Output [$Head | $SoFar])

(split [$First $Second | $Tail] anywhere into [$First] and [$Second | $Tail])
(split [$First | $More] anywhere into [$First | $Left] and $Right)
	*(split $More anywhere into $Left and $Right)

(interface (split $<Words by relation $>Rel into $>Left and $>Right))

(split $Input by relation $Rel into $Left and $Right)
	(nonempty $Input)
	*(relation $Rel)
	(collect words)
		*(dict $Rel)
	(into $WordSet)
	(nonempty $WordSet)
	*(split $Input by $WordSet into $Left and $Right)

(interface (print words $<Words))

(print words $List)
	(exhaust) {
		*($Word is one of $List)
		$Word
	}

(interface (Print Words $<Words))

(Print Words $List)
	(exhaust) {
		*($Word is one of $List)
		(uppercase) $Word
	}

(randomly select $Element from $List)
	(length of $List into $N)
	(random from 1 to $N into $Index)
	(nth $List $Index $Element)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 51: Get rid of some compiler warnings

(plural name $)		(fail)
(from $ go $ to $)	(fail)
($ unlocks $)		(fail)
(from $ through $ to $)	(fail)
(topic keyword $)	(fail)
(on every tick in $)	(fail)
(scoring enabled)	(fail)
(maximum score $)	(fail)
(amusing enabled)	(fail)
(amusing)		(fail)
(library links enabled)		(fail)
(default actions enabled)	(fail)
(heads $)			(fail)
(room $)			(fail)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 43: Fatal runtime errors

(error $Code entry point)
	(roman) \( Technische Schwierigkeiten:
	(report fatal error $Code)
	Versuche Wiederherstellung mit UNDO. \) (line)
	(if) (undo) (or) (then)
		Undo failed!
	(endif)

(report fatal error 1)	Heap space exhausted.
(report fatal error 2)	Auxiliary heap space exhausted.
(report fatal error 3)	Type error: Expected object.
(report fatal error 4)	Type error: Expected bound value.
(report fatal error 5)	Invalid dynamic operation.
(report fatal error 6)	Long-term heap space exhausted.
(report fatal error 7)	Invalid output state.
(report fatal error $)	Invalid error code!
